---
title: "RCT_Modeling"
author: "Halee Staggs"
date: "2025-05-08"
output: pdf_document
---

```{r setup, include=FALSE}
# Set global chunk options
knitr::opts_chunk$set(
  echo = TRUE,     # If false, do not show the R code , true=show code
  include = TRUE,   # Show the output and results
  message = FALSE,  # Suppress messages
  warning = FALSE   # Suppress warnings
)
```


# Per Protocol - End of Treatment 

## Prep Data

### Filter Data for Completers of End-of-Treatment Only (BL to EOT)

```{r}
#View(data_clean)
data_pp <- data_clean %>% filter(contact_end_lastvisit %in% c('EOT','FU'))
write.csv(data_pp, file = "PP/EndofTreatment/Data/data_pp.csv", row.names=F)
#View(data_pp)
#summary(data_pp)
```

#### Checking out individual profiles

```{r}
sw165 <- data_pp %>% filter(record_id == 'SW165') %>% 
  dplyr::select(contact_baseline_date, contact_tx1_date, contact_tx6_date, contact_etx_date,
         contact_6mfu_date)
sw165
```


#### Check Record-Ids associated with missing values to prevent data loss

```{r}
# Function to print record_ids with NA for each variable
print_na_record_ids <- function(df) {
  for (var in colnames(df)) {
    na_records <- df %>% filter(is.na(.data[[var]])) %>% pull(record_id)
    if (length(na_records) > 0) {
      cat(paste("Variable:", var, "\n"))
      cat("Record IDs with NA:\n")
      cat(paste(na_records, collapse = ", "), "\n\n")
    }
  }
}

#print(print_na_record_ids(data_pp))
```

#### Notes on Data Loss and Abnormal Data

* SW136 - no end of treatment data but marked as completing EOT appointment.
* SW134 - no end of treatment ISI, used FU in its place
* SW183 - no baseline ISI, no baseline ESS, used Tx1 in its place
* SW023 - incomplete baseline. No baseline FOSQ. No diaries between Tx5 and end of treatment.
* SW165 - No diaries between Tx6 and end of treatment.
* SW189 - no diaries between Tx6 and end of treatment. Just up to Tx5.
* SW210 - no diaries between Tx6 and end of treatment. Just up to Tx5.
* A lot of missing WAI from therapist/client
* SW190, SW193 completed tx adherence for both CBT-i and ABT, assigned ABT

## Primary Aims: Linear Mixed Effects Models (Time x. Group x. Outcome)

### Create Long Format for Data

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long1 <- data_pp %>%
  pivot_longer(
    cols = ends_with("_bl") | ends_with("_eot"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long1 <- data_long1 %>% 
  select(record_id, 
         contact_treatment,
         time,
         pcl,
         isi,
         pcs,
         mcs,
         penn,
         phq,
         hit,
         bpisev,
         bpiinf,
         dbas,
         fosq,
         ess)

data_long1

```

* Diaries WASO, SOL, EMA

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long2 <- data_pp %>%
  pivot_longer(
    cols = ends_with("_bl_fx_i") | ends_with("_eot_fx_i"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long2 <- data_long2 %>% 
  select(record_id, 
         contact_treatment,
         time,
         sol,
         waso,
         ema)

data_long2


```

* Diaries Metrics - Medians

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long3 <- data_pp %>%
  pivot_longer(
    cols = ends_with("_bl_md") | ends_with("_eot_md"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long3 <- data_long3 %>% 
  select(record_id, 
         contact_treatment,
         time,
         tib,
         tst,
         sol,
         waso,
         ema
         )

data_long3

```


* Diaries Metrics - Means

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long4 <- data_pp %>%
  pivot_longer(
    cols = ends_with("_bl_mn") | ends_with("_eot_mn"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long4 <- data_long4 %>% 
  select(record_id, 
         contact_treatment,
         time,
         tib,
         tst,
         se,
         sol,
         waso,
         ema
         )

data_long4

```

* Combine Long Dataframes

```{r}
# Join Data on Record ID and Time
merged_long_raw <- data_long1 %>%
  #left_join(data_long2, by = c("record_id", "time", "contact_treatment")) %>%   
  #left_join(data_long3, by = c("record_id", "time", "contact_treatment"))
  left_join(data_long4, by = c("record_id", "time", "contact_treatment"))      


# View the merged data frame
merged_long_raw

# Update the time levels from 'bl' to 'Pre' and 'eot' to 'Post', and set factor levels
merged_long_raw <- merged_long_raw %>%
  mutate(time = dplyr::recode(time, bl = "Pre", eot = "Post"),    # Recode time variable
         time = factor(time, levels = c("Pre", "Post")))   # Set order of levels for time

write.csv(merged_long_raw, "PP/EndofTreatment/Data/pp_eot_time1_time2_raw.csv", row.names = FALSE)


# Save data of CBTI group only
merged_long_raw_cbti <- merged_long_raw %>% filter(contact_treatment == 'CBTI')
write.csv(merged_long_raw_cbti, "PP/EndofTreatment/Data/pp_eot_cbti_time1_time2_raw.csv", row.names = FALSE)

```


### Create Output of Descriptive Statistics

```{r}
# Function to calculate means and standard deviations for all numeric variables
mean_sd_table_function <- function(data) {
  data %>%
    group_by(contact_treatment, time) %>%
    summarise(across(where(is.numeric), 
                     list(mean = ~ mean(.x, na.rm = TRUE), 
                          sd = ~ sd(.x, na.rm = TRUE)),
                     .names = "{col}_{fn}"))
}

# Example usage with your data
mean_sd_table <- mean_sd_table_function(merged_long_raw)

# View the result
kable(mean_sd_table)

write.csv(mean_sd_table, "PP/EndofTreatment/Data/pp_eot_time1_time2_mean_sd_table.csv", row.names = FALSE)
```


* Some general workflow settings and functions

```{r}
lmer_pp_eot_results <- list()
lmer_pp_eot_effects <- list()
lmer_pp_eot_cbti_results <- list()
lmer_pp_eot_cbti_effects <- list()


# Update the time levels from 'bl' to 'Pre' and 'eot' to 'Post', and set factor levels
merged_long <- merged_long_raw %>%
  mutate(time = dplyr::recode(time, bl = "Pre", eot = "Post"),    # Recode time variable
         time = factor(time, levels = c("Pre", "Post")))   # Set order of levels for time

merged_long_cbti <- merged_long_raw_cbti %>%
  mutate(time = dplyr::recode(time, bl = "Pre", eot = "Post"),    # Recode time variable
         time = factor(time, levels = c("Pre", "Post")))   # Set order of levels for time
  
# Function to classify effect sizes
classify_effect_size <- function(eta_squared) {
  if (eta_squared >= 0.14) {
    return("large")
  } else if (eta_squared >= 0.06) {
    return("medium")
  } else {
    return("small")
  }
}
```

### Primary Outcome

#### ISI - Treatment vs. Control

```{R}
# Filter data
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(isi))) %>%
  ungroup()

# Fit the model
isi_model <- lmerTest::lmer(isi ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(isi_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(isi_model)
r2_nakagawa

# Pairwise comparisons
emmeans(isi_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(isi_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(isi_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["isi"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(isi_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['isi_time']] <- time_label
lmer_pp_eot_effects[['isi_group']] <- group_label
lmer_pp_eot_effects[['isi_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# First, calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(isi, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Update the plot with new legend labels
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in ISI Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "ISI Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +  # Updated this line
  scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_isi_itx_plot.png", plot = p, width = 8, height = 6)

```


#### ISI - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(isi))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(isi, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
isi_model <- lmerTest::lmer(isi ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(isi_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(isi_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(isi_model, pairwise ~ time)

# Get predicted values from the model (removed contact_treatment)
predictions <- ggpredict(isi_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(isi_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["isi"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(isi_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['isi_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in ISI Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "ISI Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +  # Added this line to make the line black
  scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_isi_cbti_plot.png", plot = p, width = 8, height = 6)

```

### Secondary Outcomes


#### TIB - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long %>%
group_by(record_id) %>%
filter(all(!is.na(tib))) %>%
ungroup()


# Fit the model
tib_model <- lmerTest::lmer(tib ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(tib_model)

#Get effect sizes

r2_nakagawa <- performance::r2_nakagawa(tib_model)
r2_nakagawa

# Pairwise comparisons
emmeans(tib_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(tib_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(tib, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Extract p-values from model
model_sum <- summary(tib_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["tib"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tib_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['tib_time']] <- time_label
lmer_pp_eot_effects[['tib_group']] <- group_label
lmer_pp_eot_effects[['tib_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)),
            vjust = -1.5,
            color = "black") +
  labs(
    title = "Change in Mean TIB Pre- and Post-Treatment",
    x = "Timepoint",
    y = "TIB (hr)",
    color = "Treatment Group") +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +  # Updated to include sample sizes
  scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20))
p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_tib_itx_plot.png", plot = p, width = 8, height = 6)

```

#### TIB - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(tib))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(tib, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
tib_model <- lmerTest::lmer(tib ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(tib_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tib_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(tib_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(tib_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Extract p-values from model
model_sum <- summary(tib_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["tib"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tib_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['tib_time']] <- time_label

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean TIB Pre- and Post-Treatment",
    x = "Timepoint",
    y = "TIB (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p


ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_tib_cbti_plot.png", plot = p, width = 8, height = 6)

```

#### TST - Treatment vs. Control

```{R}
# Filter data
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(tst))) %>%
  ungroup()

# Fit the model
tst_model <- lmerTest::lmer(tst ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(tst_model)

#Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tst_model)
r2_nakagawa

# Pairwise comparisons
emmeans(tst_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(tst_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(tst, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(tst_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["tst"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tst_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['tst_time']] <- time_label
lmer_pp_eot_effects[['tst_group']] <- group_label
lmer_pp_eot_effects[['tst_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)),
            vjust = -1.5,
            color = "black") +
  labs(
    title = "Change in Mean TST Pre- and Post-Treatment",
    x = "Timepoint",
    y = "TST (hr)",
    color = "Treatment Group") +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(6, 7.5), breaks = seq(6, 7.5, by = .3)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20))

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_tst_itx_plot.png", plot = p, width = 8, height = 6)
```

#### TST - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(tst))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(tst, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
tst_model <- lmerTest::lmer(tst ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(tst_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tst_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(tst_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(tst_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(tst_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["tst"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tst_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['tst_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean TST Pre- and Post-Treatment",
    x = "Timepoint",
    y = "TST (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  scale_y_continuous(limits = c(6, 7.5), breaks = seq(6, 7.5, by = .3)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_tst_cbti_plot.png", plot = p, width = 8, height = 6)
```

#### SE - Treatment vs. Control

```{R}
# Filter data
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(se))) %>%
  ungroup()

# Fit the model
se_model <- lmerTest::lmer(se ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(se_model)

#Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(se_model)
r2_nakagawa

# Pairwise comparisons
emmeans(se_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(se_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(se, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(se_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["se"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(se_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['se_time']] <- time_label
lmer_pp_eot_effects[['se_group']] <- group_label
lmer_pp_eot_effects[['se_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)),
            vjust = -1.5,
            color = "black") +
  labs(
    title = "Change in SE Pre- and Post-Treatment",
    x = "Timepoint",
    y = "SE (%)",
    color = "Treatment Group") +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20))

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_se_itx_plot.png", plot = p, width = 8, height = 6)
```


#### SE - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(se))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(se, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
se_model <- lmerTest::lmer(se ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(se_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(se_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(se_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(se_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(se_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["se"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(se_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['se_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SE Pre- and Post-Treatment (CBTI Group)",
    x = "Timepoint",
    y = "SE (%)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(70, 100), breaks = seq(70, 100, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_se_cbti_plot.png", plot = p, width = 8, height = 6)

```

#### PHQ - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(phq))) %>%
  ungroup()

# Fit the model
phq_model <- lmerTest::lmer(phq ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(phq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(phq_model)
r2_nakagawa

# Pairwise comparisons
emmeans(phq_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(phq_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(phq, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(phq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["phq"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(phq_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['phq_time']] <- time_label
lmer_pp_eot_effects[['phq_group']] <- group_label
lmer_pp_eot_effects[['phq_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)),
            vjust = -1.5,
            color = "black") +
  labs(
    title = "Change in PHQ Score Pre- and Post-Treatment",
    x = "Timepoint",
    y = "PHQ Score",
    color = "Treatment Group") +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20))

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_phq_itx_plot.png", plot = p, width = 8, height = 6)

```


#### PHQ - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(phq))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(phq, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
phq_model <- lmerTest::lmer(phq ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(phq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(phq_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(phq_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(phq_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(phq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["phq"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(phq_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['phq_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in PHQ Score Pre- and Post-Treatment",
    x = "Timepoint",
    y = "PHQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 15), breaks = seq(0, 15, by = 3)) + # Added appropriate scale for PHQ
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_phq_cbti_plot.png", plot = p, width = 8, height = 6)
```


#### PCS - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(pcs))) %>%
  ungroup()

# Fit the model
pcs_model <- lmerTest::lmer(pcs ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(pcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(pcs_model)
r2_nakagawa

# Pairwise comparisons
emmeans(pcs_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(pcs_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(pcs, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(pcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["pcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(pcs_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['pcs_time']] <- time_label
lmer_pp_eot_effects[['pcs_group']] <- group_label
lmer_pp_eot_effects[['pcs_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SF36 PCS Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "PCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_pcs_itx_plot.png", plot = p, width = 8, height = 6)
```


#### PCS - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(pcs))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(pcs, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
pcs_model <- lmerTest::lmer(pcs ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(pcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(pcs_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(pcs_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(pcs_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(pcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["pcs"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(pcs_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['pcs_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SF36 PCS Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "PCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) + # Added appropriate scale for PCS
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_pcs_cbti_plot.png", plot = p, width = 8, height = 6)
```

#### MCS - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(mcs))) %>%
  ungroup()

# Fit the model
mcs_model <- lmerTest::lmer(mcs ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(mcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(mcs_model)
r2_nakagawa

# Pairwise comparisons
emmeans(mcs_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(mcs_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(mcs, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(mcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["mcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(mcs_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['mcs_time']] <- time_label
lmer_pp_eot_effects[['mcs_group']] <- group_label
lmer_pp_eot_effects[['mcs_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SF36 MCS Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "MCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_mcs_itx_plot.png", plot = p, width = 8, height = 6)

```


#### MCS - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(mcs))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(mcs, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
mcs_model <- lmerTest::lmer(mcs ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(mcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(mcs_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(mcs_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(mcs_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(mcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["mcs"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(mcs_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['mcs_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SF36 MCS Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "MCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(30, 55), breaks = seq(30, 55, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_mcs_cbti_plot.png", plot = p, width = 8, height = 6)
```

#### FOSQ - Treament vs. Control

```{r}
# Filter data
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(fosq))) %>%
  ungroup()

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(fosq, na.rm = TRUE), .groups = 'drop')

# Fit the model
fosq_model <- lmerTest::lmer(fosq ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(fosq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(fosq_model)
r2_nakagawa

# Pairwise comparisons
emmeans(fosq_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(fosq_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(fosq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["fosq"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(fosq_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['fosq_time']] <- time_label
lmer_pp_eot_effects[['fosq_group']] <- group_label
lmer_pp_eot_effects[['fosq_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in FOSQ Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "FOSQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(13, 16), breaks = seq(13, 16, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_fosq_itx_plot.png", plot = p, width = 8, height = 6)
```


#### FOSQ - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(fosq))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(fosq, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
fosq_model <- lmerTest::lmer(fosq ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(fosq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(fosq_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(fosq_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(fosq_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(fosq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["fosq"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(fosq_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['fosq_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in FOSQ Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "FOSQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  scale_y_continuous(limits = c(10, 20), breaks = seq(10, 20, by = 2)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_fosq_cbti_plot.png", plot = p, width = 8, height = 6)
```


#### WASO - Treatment vs. Control

```{r}
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(waso))) %>%
  ungroup()  # Ungroup to remove grouping structure after filtering

# Model
# Fit the model
waso_model <- lmerTest::lmer(waso ~ time * contact_treatment + (1|record_id), data = merged_long)
waso_model

# Get full summary
summary(waso_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(waso_model)
r2_nakagawa

# Pairwise comparisons
emmeans(waso_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(waso_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(waso, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Add model statistics as caption
# Extract p-values from model
model_sum <- summary(waso_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["waso"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  # Determine effect size category
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  # Create label based on p-value
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(waso_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['waso_time']] <- time_label
lmer_pp_eot_effects[['waso_group']] <- group_label
lmer_pp_eot_effects[['waso_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean WASO Pre- and Post-Treatment",
    x = "Timepoint",
    y = "WASO (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_waso_itx_plot.png", plot = p, width = 8, height = 6)
```


#### WASO - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(waso))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(waso, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
waso_model <- lmerTest::lmer(waso ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(waso_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(waso_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(waso_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(waso_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(waso_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["waso"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(waso_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['waso_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in WASO Pre- and Post-Treatment (CBTI Group)",
    x = "Timepoint",
    y = "WASO (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_waso_cbti_plot.png", plot = p, width = 8, height = 6)
```


#### SOL - Treatment vs. Control

```{r}
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(sol))) %>%
  ungroup()  # Ungroup to remove grouping structure after filtering

# Model
# Fit the model
sol_model <- lmerTest::lmer(sol ~ time * contact_treatment + (1|record_id), data = merged_long)
sol_model

# Get full summary
summary(sol_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(sol_model)
r2_nakagawa

# Pairwise comparisons
emmeans(sol_model, pairwise ~ time | contact_treatment)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(sol, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Get predicted values from the model
predictions <- ggpredict(sol_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Add model statistics as caption
# Extract p-values from model
model_sum <- summary(sol_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["sol"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  # Determine effect size category
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  # Create label based on p-value
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(sol_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['sol_time']] <- time_label
lmer_pp_eot_effects[['sol_group']] <- group_label
lmer_pp_eot_effects[['sol_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean SOL Pre- and Post-Treatment",
    x = "Timepoint",
    y = "SOL (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_sol_itx_plot.png", plot = p, width = 8, height = 6)
```

#### SOL - Treatment only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(sol))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(sol, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
sol_model <- lmerTest::lmer(sol ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(sol_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(sol_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(sol_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(sol_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(sol_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["sol"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(sol_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['sol_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SOL Pre- and Post-Treatment",
    x = "Timepoint",
    y = "SOL (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Added appropriate scale for SOL
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_sol_cbti_plot.png", plot = p, width = 8, height = 6)
```


#### EMA - Treatment vs. Control

```{r}
filtered_data <- merged_long %>%
  group_by(record_id) %>%
  filter(all(!is.na(ema))) %>%
  ungroup()  # Ungroup to remove grouping structure after filtering

# Model
# Fit the model
ema_model <- lmerTest::lmer(ema ~ time * contact_treatment + (1|record_id), data = merged_long)
ema_model

# Get full summary
summary(ema_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(ema_model)
r2_nakagawa

# Pairwise comparisons
emmeans(ema_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(ema_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(ema, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Add model statistics as caption
# Extract p-values from model
model_sum <- summary(ema_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_results[["ema"]] <- fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  # Determine effect size category
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  # Create label based on p-value
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(ema_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_pp_eot_effects[['ema_time']] <- time_label
lmer_pp_eot_effects[['ema_group']] <- group_label
lmer_pp_eot_effects[['ema_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean EMA Pre- and Post-Treatment",
    x = "Timepoint",
    y = "EMA (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_ema_itx_plot.png", plot = p, width = 8, height = 6)
```


#### EMA - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(ema))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(ema, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
ema_model <- lmerTest::lmer(ema ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(ema_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(ema_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(ema_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(ema_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(ema_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_eot_cbti_results[["ema"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(ema_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_pp_eot_cbti_effects[['ema_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Early Morning Awakening Pre- and Post-Treatment",
    x = "Timepoint",
    y = "EMA (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 40), breaks = seq(0, 40, by = 10)) + # Added appropriate scale for EMA
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/EndofTreatment/LMERS/Graphs/pp_eot_ema_cbti_plot.png", plot = p, width = 8, height = 6)
```


### Statistical Test Results - LMEM - Treatment vs. Control

```{r}
# Convert nested list to dataframe
lmer_pp_eot_results_df <- do.call(rbind, lapply(names(lmer_pp_eot_results), function(var) {
  df <- as.data.frame(lmer_pp_eot_results[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))

# Clean up the dataframe
lmer_pp_eot_results_df <- lmer_pp_eot_results_df %>%
  select(Variable, Parameter, everything()) %>%  # Reorder columns
  mutate(across(where(is.numeric), round, 3))   # Round numeric columns

# If you want to filter for specific effects
filtered_results <- lmer_pp_eot_results_df %>%
  filter(Parameter %in% c("timePost", "contact_treatmentCTRL", "timePost:contact_treatmentCTRL"))

# Create a wider format if needed
wide_pp_eot_results <- filtered_results %>%
  select(Variable, Parameter, `Pr(>|t|)`) %>%
  pivot_wider(
    names_from = Parameter,
    values_from = `Pr(>|t|)`,
    names_prefix = "p_"
  )

# Add p-adj to wide results
wide_pp_eot_results$p_adj_intx <- p.adjust(wide_pp_eot_results$`p_timePost:contact_treatmentCTRL`, method = "bonferroni")

# Add p-effect sizes
lmer_pp_eot_effects_df <- do.call(rbind, lapply(names(lmer_pp_eot_effects), function(var) {
  df <- as.data.frame(lmer_pp_eot_effects[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))


# Print the results
kable(print(lmer_pp_eot_results_df))  # Full results
kable(print(wide_pp_eot_results))     # Wide format results
kable(print(lmer_pp_eot_effects_df))

# Save outputs
write.csv(lmer_pp_eot_results_df, "PP/EndofTreatment/LMERS/Results/pp_eot_lmer_results.csv", row.names = FALSE)
write.csv(wide_pp_eot_results, "PP/EndofTreatment/LMERS/Results/pp_eot_lmer_p_adj.csv", row.names = FALSE)
write.csv(lmer_pp_eot_effects_df, "PP/EndofTreatment/LMERS/Results/pp_eot_lmer_effects.csv", row.names = FALSE)

```


### Statistical Test Results - LMEM - Treatment Only

```{r}
# Convert nested list to dataframe
lmer_pp_eot_cbti_results_df <- do.call(rbind, lapply(names(lmer_pp_eot_cbti_results), function(var) {
  df <- as.data.frame(lmer_pp_eot_cbti_results[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))

# Clean up the dataframe
lmer_pp_eot_cbti_results_df <- lmer_pp_eot_cbti_results_df %>%
  select(Variable, Parameter, everything()) %>%  # Reorder columns
  mutate(across(where(is.numeric), round, 3))   # Round numeric columns

# If you want to filter for specific effects (simplified for time only)
filtered_results <- lmer_pp_eot_cbti_results_df %>%
  filter(Parameter == "timePost")

# Create a wider format if needed (simplified for time only)
wide_pp_eot_cbti_results <- filtered_results %>%
  select(Variable, Parameter, `Pr(>|t|)`) %>%
  pivot_wider(
    names_from = Parameter,
    values_from = `Pr(>|t|)`,
    names_prefix = "p_"
  )

# Add p-adj to wide results
wide_pp_eot_cbti_results$p_adj_time <- p.adjust(wide_pp_eot_cbti_results$p_timePost, method = "bonferroni")

# Add effect sizes
lmer_pp_eot_cbti_effects_df <- do.call(rbind, lapply(names(lmer_pp_eot_cbti_effects), function(var) {
  data.frame(
    Variable = var,
    Effect_Label = lmer_pp_eot_cbti_effects[[var]],
    stringsAsFactors = FALSE
  )
}))

# Print the results
kable(print(lmer_pp_eot_cbti_results_df))  # Full results
kable(print(wide_pp_eot_cbti_results))     # Wide format results
kable(print(lmer_pp_eot_cbti_effects_df))  # Effect sizes

# Save outputs
write.csv(lmer_pp_eot_cbti_results_df, 
          "PP/EndofTreatment/LMERS/Results/pp_eot_cbti_lmer_results.csv", 
          row.names = FALSE)

write.csv(wide_pp_eot_cbti_results, 
          "PP/EndofTreatment/LMERS/Results/pp_eot_cbti_lmer_p_adj.csv", 
          row.names = FALSE)

write.csv(lmer_pp_eot_cbti_effects_df, 
          "PP/EndofTreatment/LMERS/Results/pp_eot_cbti_lmer_effects.csv", 
          row.names = FALSE)
```

### Correlation bewteen Numerical Variables - No Concerns for Multicollinearity

```{r, eval = F}
# Select the relevant numeric columns
numeric_data <- data_pp %>% 
  dplyr::select('demo_age', 
                'diary_total', 
                'bl_eot_time', 
                'tx_adh_mean', 
                'tx_sat_sum', 
                'ceq_credib',
                'isi_bl',
                'isi_tx1',
                'isi_eot',
                'isi_fu',
                'isi_tx1_diff',
                'pcl_bl', 
                'pcs_bl', 
                'mcs_bl', 
                'bpisev_bl',
                'bpiinf_bl', 
                'phq_bl', 
                'dbas_bl', 
                'fosq_bl', 
                'hit_bl',
                'penn_bl', 
                'ess_bl', 
                'waso_bl_md', 
                'waso_bl_fx_i',
                'tib_bl_md', 
                'sol_bl_md', 
                'sol_bl_fx_i',
                'ema_bl_md', 
                'ema_bl_fx_i',
                'isi_tx_diff', 
                'waso_md_tx_diff', 
                'waso_i_tx_diff', 
                'pcs_tx_diff', 
                'mcs_tx_diff', 
                'fosq_tx_diff', 
                'penn_tx_diff', 
                'dbas_tx_diff', 
                'pcl_tx_diff', 
                'hit_tx_diff', 
                'bpisev_tx_diff', 
                'bpiinf_tx_diff',
                'phq_tx_diff', 
                'ess_tx_diff',
                'tib_md_tx_diff', 
                'sol_md_tx_diff', 
                'sol_i_tx_diff',
                'ema_md_tx_diff', 
                'ema_i_tx_diff') %>%
  select_if(is.numeric)

# Initialize an empty data frame to store results
correlation_results <- data.frame(Variable1 = character(),
                                  Variable2 = character(),
                                  Correlation = numeric(),
                                  P_value = numeric(),
                                  stringsAsFactors = FALSE)

# Loop through each pair of variables to compute correlations and p-values
for (i in 1:(ncol(numeric_data) - 1)) {
  for (j in (i + 1):ncol(numeric_data)) {
    var1 <- colnames(numeric_data)[i]
    var2 <- colnames(numeric_data)[j]
    
    # Perform correlation test
    test_result <- cor.test(numeric_data[[var1]], numeric_data[[var2]], use = "complete.obs")
    
    # Append results to the data frame
    correlation_results <- rbind(correlation_results, 
                                 data.frame(Variable1 = var1, 
                                            Variable2 = var2, 
                                            Correlation = round(test_result$estimate, 3), 
                                            P_value = round(test_result$p.value, 4)))
  }
}

# Order by absolute magnitude of correlation value
correlation_results <- correlation_results %>%
  mutate(Abs_Correlation = abs(Correlation)) %>%
  arrange(desc(Abs_Correlation)) %>%
  select(-Abs_Correlation)  # Remove the helper column

# Display the top 15 correlations using kable()
correlation_results %>%
  head(20) %>%
  kable(caption = "Top 20 Correlations by Absolute Magnitude",
        col.names = c("Variable 1", "Variable 2", "Correlation", "P-value"),
        digits = 4)

```

```{r, eval = F}
#```{r corrplot-large, fig.width=12, fig.height=12, fig.retina=2}
corrplot(cor(data_pp %>% dplyr::select('demo_age', 
                      'diary_total', 
                      'bl_eot_time', 
                      'tx_adh_mean', 
                      'tx_sat_sum', 
                      'ceq_credib',
                      'isi_bl',
                      'isi_tx1',
                      'isi_eot',
                      'isi_fu',
                      'isi_tx1_diff',
                      'pcl_bl', 
                      'pcs_bl', 
                      'mcs_bl', 
                      'bpisev_bl',
                      'bpiinf_bl', 
                      'phq_bl', 
                      'dbas_bl', 
                      'fosq_bl', 
                      'hit_bl',
                      'penn_bl', 
                      'ess_bl', 
                      'waso_bl_md', 
                      'waso_bl_fx_i',
                      'tib_bl_md', 
                      'sol_bl_md', 
                      'sol_bl_fx_i',
                      'ema_bl_md', 
                      'ema_bl_fx_i',
                      'isi_tx_diff', 
                      'waso_md_tx_diff', 
                      'waso_i_tx_diff', 
                      'pcs_tx_diff', 
                      'mcs_tx_diff', 
                      'fosq_tx_diff', 
                      'penn_tx_diff', 
                      'dbas_tx_diff', 
                      'pcl_tx_diff', 
                      'hit_tx_diff', 
                      'bpisev_tx_diff', 
                      'bpiinf_tx_diff',
                      'phq_tx_diff', 
                      'ess_tx_diff',
                      'tib_md_tx_diff', 
                      'sol_md_tx_diff', 
                      'sol_i_tx_diff',
                      'ema_md_tx_diff', 
                      'ema_i_tx_diff'), 
             use = "complete.obs"),
         method = "number",
         type = "lower",
         number.digits = 1,
         number.cex = .8)
```


## Regression Models

```{r}
# Filter data for CBTI participants only
data_cbti <- data_pp %>%
  filter(contact_treatment == 'CBTI')

```

### Moderators - Treatment * Moderator Intx (Baselines) Predicts Change in ISI

#### Multivariate Model: Treatment effect moderated by Penn State Worry Questionnaire

```{r}

# Then run your model and plot
hypo2_mod <- glm(isi_tx_diff ~
                     phq_bl +
                     tib_bl_mn +
                     sol_bl_mn +
                     ema_bl_mn +
                     waso_bl_mn +
                     penn_bl + 
                     dbas_bl + 
                     pcl_bl + 
                     bpiinf_bl #+
                     #bpisev_bl
                   ,
                data = data_cbti,
                family = gaussian(link=identity))

# Model summary
model_summary <- summary(hypo2_mod)

# Compute the 95% confidence intervals for the coefficients
conf_intervals <- confint(hypo2_mod)

# Display the summary with confidence intervals
hypo2_mod_summary <- cbind(
  Estimate = coef(model_summary),
  `2.5 %` = conf_intervals[, 1],
  `97.5 %` = conf_intervals[, 2]
)

hypo2_mod_summ_round <- round(hypo2_mod_summary, 4)

# Function to make text bold for rows where p-value is less than 0.05
bold_significant <- function(summary_table) {
  summary_table <- as.data.frame(summary_table)
  summary_table$`Pr(>|t|)` <- ifelse(summary_table$`Pr(>|t|)` < 0.05, 
                                     paste0("**", format(summary_table$`Pr(>|t|)`, nsmall = 4), "**"),
                                     format(summary_table$`Pr(>|t|)`, nsmall = 4))
  return(summary_table)
}

# Apply bold formatting for significant p-values
coef_summary_bold <- bold_significant(hypo2_mod_summ_round)

# Display the table using kable for better formatting
kable(coef_summary_bold, format = "markdown", align = "c")

#print overall summary for other metrics
print(model_summary)

vif_results <- vif(hypo2_mod)

# Create nice VIF table
vif_table <- data.frame(
  Variable = names(vif_results),
  VIF = vif_results
) %>%
  arrange(desc(VIF))

# Print VIF results
print("Variance Inflation Factors:")
print(vif_table)

# First, get predicted values
#pred_data <- ggpredict(hypo2_mod, terms = c("contact_treatment", "penn_bl[meansd]"))

# Create base data for raw points
#raw_data <- data_pp %>%
#  select(contact_treatment, isi_tx_diff, penn_bl)

# Create the plot
#p <- ggplot() +
  # Add lines connecting groups
#  geom_line(data = pred_data,
#            aes(x = x, y = predicted, group = group, color = group),
#            size = 1) +
  # Add confidence interval ribbons
#  geom_ribbon(data = pred_data, 
#              aes(x = x, ymin = conf.low, ymax = conf.high, fill = group), 
#              alpha = 0.1) +
  # Add predicted points
#  geom_point(data = pred_data,
#             aes(x = x, y = predicted, color = group),
#             size = 3) +
  # Add raw data points
#  geom_jitter(data = raw_data,
#              aes(x = contact_treatment, y = isi_tx_diff),
#              alpha = 0.3,
#              width = 0.2,
#              height = 0) +
  # Customize labels
#  labs(title = "Moderation Effect of Baseline PENN on Treatment Outcome",
#       subtitle = "Interaction between Treatment Group",
#       x = "Treatment Type",
#       y = "Change in Insomnia Severity (ISI)",
#       color = "PENN Level",
#       fill = "PENN Level") +
  # Customize theme
#  theme_minimal() +
#  theme(
#    plot.title = element_text(hjust = 0.5),
#    plot.subtitle = element_text(hjust = 0.5),
#    legend.position = "right",
#    panel.grid.minor = element_blank()
#  ) +
  # Use grey scale with custom labels
#  scale_color_grey(labels = c("33.6" = "-1 SD: 33.6",
#                             "48.4" = "Mean: 48.4",
#                             "63.3" = "+1 SD: 63.3")) +
#  scale_fill_grey(labels = c("33.6" = "-1 SD: 33.6",
#                            "48.4" = "Mean: 48.4",
#                            "63.3" = "+1 SD: 63.3"))
#p

#ggsave(filename = "PP/EndofTreatment/Moderators/pp_penn_moderator_plot.png", plot = p, width = 8, height = 6)
```

### Mediators - CBTI * Mediator Intx (Delta) Predicts Change in ISI

#### Multivariate Model

```{R}
# First, create equivalent linear model for VIF checking
lm_equivalent <- lm(isi_tx_diff ~ phq_tx_diff + 
                                 tib_mn_tx_diff + 
                                 sol_mn_tx_diff +
                                 waso_mn_tx_diff +
                                 ema_mn_tx_diff +
                                 penn_tx_diff + 
                                 dbas_tx_diff + 
                                 pcl_tx_diff + 
                                 bpiinf_tx_diff +
                                 bpisev_tx_diff +
                                 isi_bl,
                   data = data_cbti)

# Calculate VIF
vif_results <- vif(lm_equivalent)

# Create nice VIF table
vif_table <- data.frame(
  Variable = names(vif_results),
  VIF = vif_results
) %>%
  arrange(desc(VIF))

# Print VIF results
print("Variance Inflation Factors:")
print(vif_table)

# Define the model for CBTI group only
cbti_model <- '
  # Outcome
  isi_tx_diff ~ b1*phq_tx_diff + 
                b2*tib_mn_tx_diff + 
                b3*sol_mn_tx_diff +
                b4*waso_mn_tx_diff +
                b5*ema_mn_tx_diff +
                b6*penn_tx_diff + 
                b7*dbas_tx_diff + 
                b8*pcl_tx_diff + 
                b9*bpiinf_tx_diff +
                b10*bpisev_tx_diff +
                b11*isi_bl  # Adding baseline ISI as control

  # Covariances between mediators
  phq_tx_diff ~~ tib_md_tx_diff + sol_md_tx_diff + waso_md_tx_diff + ema_md_tx_diff + penn_tx_diff + dbas_tx_diff + pcl_tx_diff + bpiinf_tx_diff + bpisev_tx_diff
  tib_md_tx_diff ~~ sol_md_tx_diff + waso_md_tx_diff + ema_md_tx_diff + penn_tx_diff + dbas_tx_diff + pcl_tx_diff + bpiinf_tx_diff + bpisev_tx_diff
  sol_md_tx_diff ~~ waso_md_tx_diff + ema_md_tx_diff + penn_tx_diff + dbas_tx_diff + pcl_tx_diff + bpiinf_tx_diff + bpisev_tx_diff
  waso_md_tx_diff ~~ ema_md_tx_diff + penn_tx_diff + dbas_tx_diff + pcl_tx_diff + bpiinf_tx_diff + bpisev_tx_diff
  ema_md_tx_diff ~~ penn_tx_diff + dbas_tx_diff + pcl_tx_diff + bpiinf_tx_diff + bpisev_tx_diff
  penn_tx_diff ~~ dbas_tx_diff + pcl_tx_diff + bpiinf_tx_diff + bpisev_tx_diff
  dbas_tx_diff ~~ pcl_tx_diff + bpiinf_tx_diff + bpisev_tx_diff
  pcl_tx_diff ~~ bpiinf_tx_diff + bpisev_tx_diff
  bpiinf_tx_diff ~~ bpisev_tx_diff
'

# Fit the model
cbti_fit <- sem(cbti_model, 
                data = data_cbti, 
                se = "bootstrap", 
                bootstrap = 1000)

# Get R-squared for outcome
r2_total <- inspect(cbti_fit, "r2")["isi_tx_diff"]

# Get standardized effects
std_effects <- standardizedSolution(cbti_fit) %>%
  filter(op == "~") %>%
  mutate(
    # Calculate unique variance explained (squared standardized coefficient)
    variance_explained = est.std^2,
    # Calculate percent of total variance
    percent_variance = (variance_explained/r2_total) * 100
  )

# Create summary table
mediator_summary <- std_effects %>%
  select(
    Mediator = rhs,
    Std_Coefficient = est.std,
    P_Value = pvalue,
    Variance_Explained = variance_explained,
    Percent_of_Total = percent_variance
  ) %>%
  arrange(desc(Variance_Explained))

# Example output
print(mediator_summary)

# Total variance explained
print(paste("Total R-squared:", round(r2_total, 3)))

write.csv(mediator_summary, "PP/EndofTreatment/Mediators/pp_eot_mediator_analysis.csv", row.names = FALSE)
```



# Per Protocol - Follow Up

## Filter Data for Follow-Up Completers

```{r}
data_pp_fu <- data_clean %>% filter(contact_end_lastvisit == 'FU')
#View(data_pp_fu)
table(data_pp_fu$contact_treatment)
```

## Linear Mixed Effects Models

```{r}
lmer_pp_fu_results <- list()
lmer_pp_fu_effects <- list()
lmer_pp_cbti_results <- list()
lmer_pp_cbti_effects <- list()
```

### Create Long Format for Data

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long1 <- data_pp_fu %>%
  pivot_longer(
    cols = ends_with("_bl") | ends_with("_eot") | ends_with("_fu"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot|fu)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long1 <- data_long1 %>% 
  select(record_id, 
         contact_treatment,
         time,
         pcl,
         isi,
         pcs,
         mcs,
         penn,
         phq,
         hit,
         bpisev,
         bpiinf,
         dbas,
         fosq,
         ess)

data_long1

```

* Diaries WASO, SOL, EMA

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long2 <- data_pp_fu %>%
  pivot_longer(
    cols = ends_with("_bl_fx_i") | ends_with("_eot_fx_i") | ends_with("_fu_fx_i"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot|fu)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long2 <- data_long2 %>% 
  select(record_id, 
         contact_treatment,
         time,
         sol,
         waso,
         ema)

data_long2


```

* Diaries TIB

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long3 <- data_pp_fu %>%
  pivot_longer(
    cols = ends_with("_bl_md") | ends_with("_eot_md") | ends_with("_fu_md"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot|fu)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long3 <- data_long3 %>% 
  select(record_id, 
         contact_treatment,
         time,
         tib,
         tst,
         sol,
         waso,
         ema)

data_long3

```


* Diaries Metrics - Means

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long4 <- data_pp_fu %>%
  pivot_longer(
    cols = ends_with("_bl_mn") | ends_with("_eot_mn") | ends_with("_fu_md"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot|fu)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long4 <- data_long4 %>% 
  select(record_id, 
         contact_treatment,
         time,
         tib,
         tst,
         se,
         sol,
         waso,
         ema
         )

data_long4

```

* Combine Long Dataframes

```{r}
# Join Data on Record ID and Time
merged_long_fu <- data_long1 %>%
  #left_join(data_long2, by = c("record_id", "time", "contact_treatment")) %>%   
  #left_join(data_long3, by = c("record_id", "time", "contact_treatment"))
  left_join(data_long4, by = c("record_id", "time", "contact_treatment"))


# Update the time levels from 'bl' to 'Pre' and 'eot' to 'Post', and set factor levels
merged_long_fu <- merged_long_fu %>%
  mutate(time = dplyr::recode(time, bl = "Pre", eot = "Post", fu = "FollowUp"),    # Recode time variable
         time = factor(time, levels = c("Pre", "Post", "FollowUp")))   # Set order of levels for time

# Save data of CBTI group only
merged_long_fu_cbti <- merged_long_fu %>% filter(contact_treatment == 'CBTI')
write.csv(merged_long_fu_cbti, "PP/FollowUp/Data/pp_fu_cbti_time1_time2_raw.csv", row.names = FALSE)

write.csv(merged_long_fu, "PP/FollowUp/Data/pp_fu_raw_time1_time2_time3.csv", row.names = FALSE)
```


### Create Output of Descriptive Statistics

```{r}
mean_sd_table_fu <- mean_sd_table_function(merged_long_fu)

# View the result
kable(mean_sd_table_fu)

write.csv(mean_sd_table_fu, "PP/FollowUp/Data/pp_fu_raw_mean_sd_table.csv", row.names = FALSE)
```

#### Primary outcome

##### ISI - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(isi))) %>%
  ungroup()

# Fit the model
isi_model <- lmerTest::lmer(isi ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(isi_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(isi_model)
r2_nakagawa

# Pairwise comparisons
emmeans(isi_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(isi_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(isi, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(isi_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["isi"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(isi_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['isi_p_time']] <- time_post_label
lmer_pp_fu_effects[['isi_f_time']] <- time_fu_label
lmer_pp_fu_effects[['isi_group']] <- group_label
lmer_pp_fu_effects[['isi_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['isi_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in ISI Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "ISI Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_isi_itx_plot.png", plot = p, width = 8, height = 6)
```

##### ISI - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(isi))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(isi, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
isi_model <- lmerTest::lmer(isi ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(isi_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(isi_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(isi_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(isi_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(isi_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["isi"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(isi_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['isi_post']] <- time_post_label
lmer_pp_cbti_effects[['isi_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in ISI Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "ISI Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_isi_cbti_plot.png", plot = p, width = 8, height = 6)
```

#### Secondary Outcomes

##### TIB - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(tib))) %>%
  ungroup()

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(tib, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Fit the model
tib_model <- lmerTest::lmer(tib ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(tib_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tib_model)
r2_nakagawa

# Pairwise comparisons
emmeans(tib_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(tib_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(tib_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["tib"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tib_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['tib_p_time']] <- time_post_label
lmer_pp_fu_effects[['tib_f_time']] <- time_fu_label
lmer_pp_fu_effects[['tib_group']] <- group_label
lmer_pp_fu_effects[['tib_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['tib_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean TIB Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "TIB (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_tib_itx_plot.png", plot = p, width = 8, height = 6)
```


##### TIB - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(tib))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(tib, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
tib_model <- lmerTest::lmer(tib ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(tib_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tib_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(tib_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(tib_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(tib_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["tib"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tib_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['tib_post']] <- time_post_label
lmer_pp_cbti_effects[['tib_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend and SD labels
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in TIB Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "TIB (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_tib_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### TST - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(tst))) %>%
  ungroup()

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(tst, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Fit the model
tst_model <- lmerTest::lmer(tst ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(tst_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tst_model)
r2_nakagawa

# Pairwise comparisons
emmeans(tst_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(tst_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(tst_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["tst"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tst_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['tst_p_time']] <- time_post_label
lmer_pp_fu_effects[['tst_f_time']] <- time_fu_label
lmer_pp_fu_effects[['tst_group']] <- group_label
lmer_pp_fu_effects[['tst_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['tst_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean TST Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "TST (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(6, 8), breaks = seq(6, 8, by = .2)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_tst_itx_plot.png", plot = p, width = 8, height = 6)
```

##### TST - Treatment Only

```{R}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(tst))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(tst, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
tst_model <- lmerTest::lmer(tst ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(tst_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tst_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(tst_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(tst_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(tst_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["tst"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tst_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['tst_post']] <- time_post_label
lmer_pp_cbti_effects[['tst_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in TST Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "TST (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_tst_cbti_plot.png", plot = p, width = 8, height = 6)
```

##### SE - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(se))) %>%
  ungroup()

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(se, na.rm = TRUE), .groups = 'drop')

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Fit the model
se_model <- lmerTest::lmer(se ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(se_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(se_model)
r2_nakagawa

# Pairwise comparisons
emmeans(se_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(se_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Extract p-values from model
model_sum <- summary(se_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["se"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(se_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['se_p_time']] <- time_post_label
lmer_pp_fu_effects[['se_f_time']] <- time_fu_label
lmer_pp_fu_effects[['se_group']] <- group_label
lmer_pp_fu_effects[['se_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['se_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SE Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "Sleep Efficiency (%)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(75, 100), breaks = seq(75, 100, by = 10)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_se_itx_plot.png", plot = p, width = 8, height = 6)
```

##### SE - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(se))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(se, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
se_model <- lmerTest::lmer(se ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(se_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(se_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(se_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(se_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(se_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["se"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(se_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['se_post']] <- time_post_label
lmer_pp_cbti_effects[['se_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SE Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "SE (%)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(70, 95), breaks = seq(70, 95, by = 5)) + # Adjusted for SE percentages
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_se_cbti_plot.png", plot = p, width = 8, height = 6)
```

##### PHQ - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(phq))) %>%
  ungroup()

# Fit the model
phq_model <- lmerTest::lmer(phq ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(phq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(phq_model)
r2_nakagawa

# Pairwise comparisons
emmeans(phq_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(phq_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(phq, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(phq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["phq"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(phq_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['phq_p_time']] <- time_post_label
lmer_pp_fu_effects[['phq_f_time']] <- time_fu_label
lmer_pp_fu_effects[['phq_group']] <- group_label
lmer_pp_fu_effects[['phq_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['phq_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in PHQ Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "PHQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_phq_itx_plot.png", plot = p, width = 8, height = 6)
```


##### PHQ - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(phq))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(phq, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
phq_model <- lmerTest::lmer(phq ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(phq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(phq_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(phq_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(phq_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(phq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["phq"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(phq_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['phq_post']] <- time_post_label
lmer_pp_cbti_effects[['phq_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in PHQ-9 Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "PHQ-9 Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 15), breaks = seq(0, 15, by = 3)) + # Adjusted for PHQ-9 scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_phq_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### PCS - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(pcs))) %>%
  ungroup()

# Test Stat Assumptions
# Levene's test for homogeneity of variances
leveneTest(pcs ~ contact_treatment * time, data = filtered_data)
# Shapiro-Wilk test on each group
filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(
    shapiro_p = shapiro.test(pcs)$p.value
  )

# Fit the model
pcs_model <- lmerTest::lmer(pcs ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(pcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(pcs_model)
r2_nakagawa

# Pairwise comparisons
emmeans(pcs_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(pcs_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(pcs, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(pcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["pcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(pcs_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['pcs_p_time']] <- time_post_label
lmer_pp_fu_effects[['pcs_f_time']] <- time_fu_label
lmer_pp_fu_effects[['pcs_group']] <- group_label
lmer_pp_fu_effects[['pcs_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['pcs_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SF36 PCS Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "PCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_pcs_itx_plot.png", plot = p, width = 8, height = 6)
```


##### PCS - Treatment Only

```{R}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(pcs))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(pcs, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
pcs_model <- lmerTest::lmer(pcs ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(pcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(pcs_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(pcs_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(pcs_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(pcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["pcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(pcs_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['pcs_post']] <- time_post_label
lmer_pp_cbti_effects[['pcs_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SF36 PCS Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "PCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) + # Adjusted for PCS scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_pcs_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### MCS - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(mcs))) %>%
  ungroup()

# Test Stat Assumptions
# Levene's test for homogeneity of variances
leveneTest(mcs ~ contact_treatment * time, data = filtered_data)
# Shapiro-Wilk test on each group
filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(
    shapiro_p = shapiro.test(mcs)$p.value
  )

# Fit the model
mcs_model <- lmerTest::lmer(mcs ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(mcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(mcs_model)
r2_nakagawa

# Pairwise comparisons
emmeans(mcs_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(mcs_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(mcs, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(mcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["mcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(mcs_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['mcs_p_time']] <- time_post_label
lmer_pp_fu_effects[['mcs_f_time']] <- time_fu_label
lmer_pp_fu_effects[['mcs_group']] <- group_label
lmer_pp_fu_effects[['mcs_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['mcs_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SF36 MCS Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "MCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_mcs_itx_plot.png", plot = p, width = 8, height = 6)
```

##### MCS - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(mcs))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(mcs, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
mcs_model <- lmerTest::lmer(mcs ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(mcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(mcs_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(mcs_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(mcs_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(mcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["mcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(mcs_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['mcs_post']] <- time_post_label
lmer_pp_cbti_effects[['mcs_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SF36 MCS Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "MCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_mcs_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### FOSQ - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(fosq))) %>%
  ungroup()

# Test Stat Assumptions
# Levene's test for homogeneity of variances
leveneTest(fosq ~ contact_treatment * time, data = filtered_data)
# Shapiro-Wilk test on each group
filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(
    shapiro_p = shapiro.test(fosq)$p.value
  )

# Fit the model
fosq_model <- lmerTest::lmer(fosq ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(fosq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(fosq_model)
r2_nakagawa

# Pairwise comparisons
emmeans(fosq_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(fosq_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(fosq, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(fosq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["fosq"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(fosq_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['fosq_p_time']] <- time_post_label
lmer_pp_fu_effects[['fosq_f_time']] <- time_fu_label
lmer_pp_fu_effects[['fosq_group']] <- group_label
lmer_pp_fu_effects[['fosq_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['fosq_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in FOSQ Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "FOSQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_fosq_itx_plot.png", plot = p, width = 8, height = 6)
```

##### FOSQ - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(fosq))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(fosq, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
fosq_model <- lmerTest::lmer(fosq ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(fosq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(fosq_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(fosq_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(fosq_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(fosq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["fosq"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(fosq_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['fosq_post']] <- time_post_label
lmer_pp_cbti_effects[['fosq_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in FOSQ Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "FOSQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(10, 20), breaks = seq(10, 20, by = 2)) + # Adjusted for FOSQ scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_fosq_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### WASO - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(waso))) %>%
  ungroup()

# Test Stat Assumptions
# Levene's test for homogeneity of variances
leveneTest(waso ~ contact_treatment * time, data = filtered_data)
# Shapiro-Wilk test on each group
filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(
    shapiro_p = shapiro.test(waso)$p.value
  )

# Fit the model
waso_model <- lmerTest::lmer(waso ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(waso_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(waso_model)
r2_nakagawa

# Pairwise comparisons
emmeans(waso_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(waso_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(waso, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(waso_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["waso"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(waso_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['waso_p_time']] <- time_post_label
lmer_pp_fu_effects[['waso_f_time']] <- time_fu_label
lmer_pp_fu_effects[['waso_group']] <- group_label
lmer_pp_fu_effects[['waso_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['waso_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.2f (%.2f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean WASO Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "WASO (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_waso_itx_plot.png", plot = p, width = 8, height = 6)
```

##### WASO - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(waso))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(waso, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
waso_model <- lmerTest::lmer(waso ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(waso_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(waso_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(waso_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(waso_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(waso_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["waso"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(waso_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['waso_post']] <- time_post_label
lmer_pp_cbti_effects[['waso_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in WASO Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "WASO (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_waso_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### SOL - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(sol))) %>%
  ungroup()

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(sol, na.rm = TRUE), .groups = 'drop')

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Fit the model
sol_model <- lmerTest::lmer(sol ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(sol_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(sol_model)
r2_nakagawa

# Pairwise comparisons
emmeans(sol_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(sol_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Extract p-values from model
model_sum <- summary(sol_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["sol"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(sol_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['sol_p_time']] <- time_post_label
lmer_pp_fu_effects[['sol_f_time']] <- time_fu_label
lmer_pp_fu_effects[['sol_group']] <- group_label
lmer_pp_fu_effects[['sol_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['sol_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean SOL Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "SOL (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(0, 60), breaks = seq(0, 60, by = 15)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_sol_itx_plot.png", plot = p, width = 8, height = 6)
```


##### SOL - Treatment Only

```{R}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(sol))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(sol, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
sol_model <- lmerTest::lmer(sol ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(sol_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(sol_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(sol_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(sol_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(sol_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["sol"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(sol_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['sol_post']] <- time_post_label
lmer_pp_cbti_effects[['sol_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in SOL Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "SOL (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Adjusted for SOL scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_sol_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### EMA - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(ema))) %>%
  ungroup()

# Fit the model
ema_model <- lmerTest::lmer(ema ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(ema_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(ema_model)
r2_nakagawa

# Pairwise comparisons
emmeans(ema_model, pairwise ~ time | contact_treatment)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(ema, na.rm = TRUE), .groups = 'drop')

# Get predicted values from the model
predictions <- ggpredict(ema_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(ema_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_fu_results[["ema"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(ema_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_pp_fu_effects[['ema_p_time']] <- time_post_label
lmer_pp_fu_effects[['ema_f_time']] <- time_fu_label
lmer_pp_fu_effects[['ema_group']] <- group_label
lmer_pp_fu_effects[['ema_p_group_intx']] <- post_group_int_label
lmer_pp_fu_effects[['ema_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Mean EMA Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "EMA (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_ema_itx_plot.png", plot = p, width = 8, height = 6)
```

##### EMA - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(ema))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(ema, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
ema_model <- lmerTest::lmer(ema ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(ema_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(ema_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(ema_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(ema_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(ema_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_pp_cbti_results[["ema"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(ema_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_pp_cbti_effects[['ema_post']] <- time_post_label
lmer_pp_cbti_effects[['ema_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "Change in Early Morning Awakening Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "EMA (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Adjusted for EMA scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "PP/FollowUp/LMERS/Graphs/pp_fu_ema_cbti_plot.png", plot = p, width = 8, height = 6)
```


#### Statistical Test Results - LMEMs - Treatment vs. Control

```{r}
# Convert nested list to dataframe
lmer_pp_fu_results_df <- do.call(rbind, lapply(names(lmer_pp_fu_results), function(var) {
  df <- as.data.frame(lmer_pp_fu_results[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))

# Clean up the dataframe
lmer_pp_fu_results_df <- lmer_pp_fu_results_df %>%
  select(Variable, Parameter, everything()) %>%  # Reorder columns
  mutate(across(where(is.numeric), round, 3))   # Round numeric columns

# Filter for specific effects
filtered_results <- lmer_pp_fu_results_df %>%
  filter(Parameter %in% c("timePost", 
                          "timeFollowUp",
                          "contact_treatmentCTRL", 
                          "timePost:contact_treatmentCTRL",
                          "timeFollowUp:contact_treatmentCTRL"))

# Create wider format
wide_pp_fu_results <- filtered_results %>%
  select(Variable, Parameter, `Pr(>|t|)`) %>%
  pivot_wider(
    names_from = Parameter,
    values_from = `Pr(>|t|)`,
    names_prefix = "p_"
  )

wide_pp_fu_results

# Add adjusted p-values
wide_pp_fu_results$p_adj_fu_intx <- round(p.adjust(wide_pp_fu_results$`p_timeFollowUp:contact_treatmentCTRL`, method = "bonferroni"), 6)

# Add effect sizes
lmer_pp_fu_effects_df <- do.call(rbind, lapply(names(lmer_pp_fu_effects), function(var) {
  df <- as.data.frame(lmer_pp_fu_effects[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))

# Print the results
kable(print(lmer_pp_fu_results_df))  # Full results
kable(print(wide_pp_fu_results))     # Wide format results
kable(print(lmer_pp_fu_effects_df))  # Effect sizes

write.csv(lmer_pp_fu_results_df, "PP/FollowUp/LMERS/Results/pp_fu_eot_lmer_results.csv", row.names = FALSE)
write.csv(wide_pp_fu_results, "PP/FollowUp/LMERS/Results/pp_fu_p_lmer_p_adj.csv", row.names = FALSE)
write.csv(lmer_pp_fu_effects_df, "PP/FollowUp/LMERS/Results/pp_fu_lmer_effects.csv", row.names = FALSE)

```

#### Statistical Test Results - LMEMs - Treatment Only

```{r}
# Convert nested list to dataframe
lmer_pp_cbti_results_df <- do.call(rbind, lapply(names(lmer_pp_cbti_results), function(var) {
  df <- as.data.frame(lmer_pp_cbti_results[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))

# Clean up the dataframe
lmer_pp_cbti_results_df <- lmer_pp_cbti_results_df %>%
  select(Variable, Parameter, everything()) %>%  # Reorder columns
  mutate(across(where(is.numeric), round, 3))   # Round numeric columns

# Filter for specific effects (simplified for time only)
filtered_results <- lmer_pp_cbti_results_df %>%
  filter(Parameter %in% c("timePost", 
                         "timeFollowUp"))

# Create wider format
wide_pp_cbti_results <- filtered_results %>%
  select(Variable, Parameter, `Pr(>|t|)`) %>%
  pivot_wider(
    names_from = Parameter,
    values_from = `Pr(>|t|)`,
    names_prefix = "p_"
  )

# Add adjusted p-values for both timepoints
wide_pp_cbti_results <- wide_pp_cbti_results %>%
  mutate(
    p_adj_post = round(p.adjust(p_timePost, method = "bonferroni"), 6),
    p_adj_fu = round(p.adjust(p_timeFollowUp, method = "bonferroni"), 6)
  )

# Add effect sizes
lmer_pp_cbti_effects_df <- do.call(rbind, lapply(names(lmer_pp_cbti_effects), function(var) {
  data.frame(
    Variable = var,
    Effect_Label = lmer_pp_cbti_effects[[var]],
    stringsAsFactors = FALSE
  )
}))

# Print the results
kable(print(lmer_pp_cbti_results_df))  # Full results
kable(print(wide_pp_cbti_results))     # Wide format results
kable(print(lmer_pp_cbti_effects_df))  # Effect sizes

# Save results
write.csv(lmer_pp_cbti_results_df, 
          "PP/FollowUp/LMERS/Results/pp_fu_cbti_lmer_results.csv", 
          row.names = FALSE)

write.csv(wide_pp_cbti_results, 
          "PP/FollowUp/LMERS/Results/pp_fu_cbti_lmer_p_adj.csv", 
          row.names = FALSE)

write.csv(lmer_pp_cbti_effects_df, 
          "PP/FollowUp/LMERS/Results/pp_fu_cbti_lmer_effects.csv", 
          row.names = FALSE)

```


### Regression Models

```{r}
# Filter data for CBTI participants only
data_fu_cbti <- data_pp_fu %>%
  filter(contact_treatment == 'CBTI')

```

#### Moderators - Treatment * Moderator Intx (Baselines) Predict Follow Up Change in ISI

##### Multivariate Model:

```{r}
hypo2_mod <- glm(isi_fu_diff ~
                     phq_bl +
                     tib_bl_mn +
                     sol_bl_mn +
                     ema_bl_mn +
                     waso_bl_mn +
                     penn_bl + 
                     dbas_bl + 
                     pcl_bl + 
                     bpiinf_bl #+
                     #bpisev_bl
                 ,
                data = data_fu_cbti,
                family = gaussian(link=identity))

# Model summary
model_summary <- summary(hypo2_mod)

# Compute the 95% confidence intervals for the coefficients
conf_intervals <- confint(hypo2_mod)

# Display the summary with confidence intervals
hypo2_mod_summary <- cbind(
  Estimate = coef(model_summary),
  `2.5 %` = conf_intervals[, 1],
  `97.5 %` = conf_intervals[, 2]
)

hypo2_mod_summ_round <- round(hypo2_mod_summary, 4)

# Function to make text bold for rows where p-value is less than 0.05
bold_significant <- function(summary_table) {
  summary_table <- as.data.frame(summary_table)
  summary_table$`Pr(>|t|)` <- ifelse(summary_table$`Pr(>|t|)` < 0.05, 
                                     paste0("**", format(summary_table$`Pr(>|t|)`, nsmall = 4), "**"),
                                     format(summary_table$`Pr(>|t|)`, nsmall = 4))
  return(summary_table)
}

# Apply bold formatting for significant p-values
coef_summary_bold <- bold_significant(hypo2_mod_summ_round)

# Display the table using kable for better formatting
kable(coef_summary_bold, format = "markdown", align = "c")

#print overall summary for other metrics
print(model_summary)

vif_results <- vif(hypo2_mod)

# Create nice VIF table
vif_table <- data.frame(
  Variable = names(vif_results),
  VIF = vif_results
) %>%
  arrange(desc(VIF))

# Print VIF results
print("Variance Inflation Factors:")
print(vif_table)

# First, get predicted values
#pred_data <- ggpredict(hypo2_mod, terms = c("contact_treatment", "penn_bl[meansd]"))

# Create base data for raw points
#raw_data <- data_pp_fu %>%
#  select(contact_treatment, isi_tx_diff, penn_bl)

# Create the plot
#p <- ggplot() +
  # Add lines connecting groups
#  geom_line(data = pred_data,
#            aes(x = x, y = predicted, group = group, color = group),
#            size = 1) +
  # Add confidence interval ribbons
#  geom_ribbon(data = pred_data, 
#              aes(x = x, ymin = conf.low, ymax = conf.high, fill = group), 
#              alpha = 0.1) +
  # Add predicted points
#  geom_point(data = pred_data,
#             aes(x = x, y = predicted, color = group),
#             size = 3) +
  # Add raw data points
#  geom_jitter(data = raw_data,
#              aes(x = contact_treatment, y = isi_tx_diff),
#              alpha = 0.3,
#              width = 0.2,
#              height = 0) +
  # Customize labels
#  labs(title = "Moderation Effect of Baseline PENN on Follow Up Outcome",
#       subtitle = "Interaction between Treatment Group",
#       x = "Treatment Type",
#       y = "Change in Insomnia Severity (ISI)",
#       color = "PENN Level",
#       fill = "PENN Level") +
  # Customize theme
#  theme_minimal() +
#  theme(
#    plot.title = element_text(hjust = 0.5),
#    plot.subtitle = element_text(hjust = 0.5),
#    legend.position = "right",
#    panel.grid.minor = element_blank()
#  ) +
  # Use grey scale with custom labels
#  scale_color_grey(labels = c("32.5" = "-1 SD: 32.5",
#                             "47.6" = "Mean: 47.6",
#                             "62.6" = "+1 SD: 62.6")) +
#  scale_fill_grey(labels = c("32.5" = "-1 SD: 32.5",
#                            "47.6" = "Mean: 47.6",
#                            "62.6" = "+1 SD: 62.6"))
#p

#ggsave(filename = "PP/FollowUp/Moderators/pp_fu_penn_moderator_plot.png", plot = p, width = 8, height = 6)
```


#### Mediators - CBTI * Mediator Intx Predicts Follow Up Change in ISI

##### Multivariate Model


```{R}
# First, create equivalent linear model for VIF checking
lm_equivalent <- lm(isi_fu_diff ~ phq_fu_diff + 
                                 tib_mn_fu_diff + 
                                 sol_mn_fu_diff +
                                 waso_mn_fu_diff +
                                 ema_mn_fu_diff +
                                 penn_fu_diff + 
                                 dbas_fu_diff + 
                                 pcl_fu_diff + 
                                 bpiinf_fu_diff +
                                 bpisev_fu_diff +
                                 isi_bl,
                   data = data_fu_cbti)

# Calculate VIF
vif_results <- vif(lm_equivalent)

# Create nice VIF table
vif_table <- data.frame(
  Variable = names(vif_results),
  VIF = vif_results
) %>%
  arrange(desc(VIF))

# Print VIF results
print("Variance Inflation Factors:")
print(vif_table)


# Define the model for CBTI group only
cbti_model <- '
  # Outcome
  isi_fu_diff ~ b1*phq_fu_diff + 
                b2*tib_mn_fu_diff + 
                b3*sol_mn_fu_diff +
                b4*waso_mn_fu_diff +
                b5*ema_mn_fu_diff +
                b6*penn_fu_diff + 
                b7*dbas_fu_diff + 
                b8*pcl_fu_diff + 
                b9*bpiinf_fu_diff +
                b10*bpisev_fu_diff +
                b11*isi_bl  # Adding baseline ISI as control

  # Covariances between mediators
  phq_fu_diff ~~ tib_md_fu_diff + sol_md_fu_diff + waso_md_fu_diff + ema_md_fu_diff + penn_fu_diff + dbas_fu_diff + pcl_fu_diff + bpiinf_fu_diff + bpisev_fu_diff
  tib_md_fu_diff ~~ sol_md_fu_diff + waso_md_fu_diff + ema_md_fu_diff + penn_fu_diff + dbas_fu_diff + pcl_fu_diff + bpiinf_fu_diff + bpisev_fu_diff
  sol_md_fu_diff ~~ waso_md_fu_diff + ema_md_fu_diff + penn_fu_diff + dbas_fu_diff + pcl_fu_diff + bpiinf_fu_diff + bpisev_fu_diff
  waso_md_fu_diff ~~ ema_md_fu_diff + penn_fu_diff + dbas_fu_diff + pcl_fu_diff + bpiinf_fu_diff + bpisev_fu_diff
  ema_md_fu_diff ~~ penn_fu_diff + dbas_fu_diff + pcl_fu_diff + bpiinf_fu_diff + bpisev_fu_diff
  penn_fu_diff ~~ dbas_fu_diff + pcl_fu_diff + bpiinf_fu_diff + bpisev_fu_diff
  dbas_fu_diff ~~ pcl_fu_diff + bpiinf_fu_diff + bpisev_fu_diff
  pcl_fu_diff ~~ bpiinf_fu_diff + bpisev_fu_diff
  bpiinf_fu_diff ~~ bpisev_fu_diff
'

# Fit the model
cbti_fit <- sem(cbti_model, 
                data = data_fu_cbti, 
                se = "bootstrap", 
                bootstrap = 1000)

# Get R-squared for outcome
r2_total <- inspect(cbti_fit, "r2")["isi_fu_diff"]

# Get standardized effects
std_effects <- standardizedSolution(cbti_fit) %>%
  filter(op == "~") %>%
  mutate(
    # Calculate unique variance explained (squared standardized coefficient)
    variance_explained = est.std^2,
    # Calculate percent of total variance
    percent_variance = (variance_explained/r2_total) * 100
  )

# Create summary table
mediator_summary <- std_effects %>%
  select(
    Mediator = rhs,
    Std_Coefficient = est.std,
    P_Value = pvalue,
    Variance_Explained = variance_explained,
    Percent_of_Total = percent_variance
  ) %>%
  arrange(desc(Variance_Explained))

# Example output
print(mediator_summary)

# Total variance explained
print(paste("Total R-squared:", round(r2_total, 3)))

write.csv(mediator_summary, "PP/FollowUp/Mediators/pp_fu_mediator_analysis.csv", row.names = FALSE)
```

# Intent-to-Treat Analysis

## Through End of Treatment

### Prep Data

```{r}
# View(data_clean)

# Drop all follow up columns to reduce computational time for input
#data_itt <- data_clean %>% dplyr::select(-contains("_fu"))

# Save raw data to directory
#write.csv(data_itt, "ITT/Data/itt_prep_raw_data.csv", row.names = FALSE)

# Check number of randomized to treatment
#table(data_itt$contact_treatment)
```

### Transform Data Functions

```{r}
# Function to center and scale data
center_scale_data <- function(data, exclude_cols = NULL) {
  # Store original column names
  col_names <- names(data)
  
  # Identify numeric columns (excluding specified columns)
  numeric_cols <- sapply(data, is.numeric)
  if (!is.null(exclude_cols)) {
    numeric_cols[exclude_cols] <- FALSE
  }
  
  # Create output dataframe
  scaled_data <- data
  
  # Store scaling parameters
  scaling_params <- list()
  
  # Scale each numeric column
  for (col in col_names[numeric_cols]) {
    # Calculate mean and sd
    col_mean <- mean(data[[col]], na.rm = TRUE)
    col_sd <- sd(data[[col]], na.rm = TRUE)
    
    # Store parameters
    scaling_params[[col]] <- list(
      mean = col_mean,
      sd = col_sd
    )
    
    # Scale the data
    scaled_data[[col]] <- (data[[col]] - col_mean) / col_sd
  }
  
  # Return both scaled data and scaling parameters
  return(list(
    scaled_data = scaled_data,
    scaling_params = scaling_params
  ))
}

# Function to reverse the scaling
reverse_scaling <- function(scaled_data, scaling_params) {
  # Create output dataframe
  original_scale_data <- scaled_data
  
  # Reverse scaling for each column
  for (col in names(scaling_params)) {
    # Get original mean and sd
    col_mean <- scaling_params[[col]]$mean
    col_sd <- scaling_params[[col]]$sd
    
    # Reverse the scaling
    original_scale_data[[col]] <- (scaled_data[[col]] * col_sd) + col_mean
  }
  
  return(original_scale_data)
}
```

### Apply to Data

```{r}
# Scale the data
# scaled_result <- center_scale_data(your_data, exclude_cols = c("id", "group"))
# scaled_data <- scaled_result$scaled_data
# scaling_params <- scaled_result$scaling_params
# Reverse the scaling
# original_data <- reverse_scaling(scaled_data, scaling_params)

# Apply skew correction, centering, and scaling
#corrected_itt <- center_scale_data(data_itt, exclude_cols = c("record_id"))
#scaling_params <- corrected_itt$scaling_params
#corrected_itt <- corrected_itt$scaled_data

# Save transformed data to directory
#write.csv(corrected_itt, "ITT/Data/itt_prep_transformed_data.csv", row.names = FALSE)

#View(corrected_itt)
```






### Impute Missing Data via Multiple Imputations - commented out after running this once

```{r}
# Perform multiple imputation on scaled data
#imputed_dataset <- mice(corrected_itt %>% dplyr::select(-'record_id'), m = 5, method = "pmm", ridge = 0.01, seed = 1)

# Inspect the imputed datasets
#print(imputed_dataset)
```

```{r}
# Combine the imputed datasets into one dataframe
#combined_imputed_data <- complete(imputed_dataset, "long", include = FALSE)

# Drop extra columns
#combined_imputed_data <- combined_imputed_data %>% select(!c(.imp, .id))

# Add new index column for ID
#combined_imputed_data$record_id <- seq_len(nrow(combined_imputed_data))

# Save the dataframe as a .csv file for scaled, imputed data
#write.csv(combined_imputed_data, "ITT/Data/itt_imputed_data.csv", row.names = FALSE)

# Undo scaling of ITT data so its back in original units
#itt_raw <- reverse_scaling(combined_imputed_data, scaling_params)
#View(itt_raw)

# Save ITT data in original units
#write.csv(itt_raw, "ITT/Data/itt_unscaled_data.csv", row.names = FALSE)

itt_raw <- read_csv("ITT/Data/itt_unscaled_data.csv")

```

```{r}
# Update treatment label to CTRL for abti
#View(itt_raw)
#str(itt_raw$contact_treatment)

itt_raw$contact_treatment <- factor(itt_raw$contact_treatment,
                                    levels = c('CBTI', 'ABTI'),
                                    labels = c('CBTI', 'CTRL'))

```


### Linear Mixed Effects Models

```{r}
lmer_itt_eot_results <- list()
lmer_itt_eot_effects <- list()
lmer_itt_eot_cbti_results <- list()
lmer_itt_eot_cbti_effects <- list()
```


#### Delta Differences for Abstract Reporting (means, sd)

```{r}
#itt_table %>%
#  gt() %>%
#  fmt_number(columns = c(mean, sd), decimals = 2) %>%
#  cols_label(
#    contact_treatment = "Treatment Group",
#    variable = "Variable",
#    mean = "Mean",
#    sd = "SD"
#  ) %>%
#  tab_header(
#    title = "Treatment Group Differences"
#  ) %>%
#  gtsave("ITT/Graphs/itt_delta_table.png")

# Save as TXT
#write.table(itt_table, 
#            file = "ITT/Data/itt_table.txt", 
#            sep = "\t", 
#            row.names = FALSE, 
#            quote = FALSE)

```



#### Create Data in Long Format

```{r}
#### Create Long Format for Data
# Pivot the data from wide to long format for all pre- and post- variables
data_long1 <- itt_raw %>%
  pivot_longer(
    cols = ends_with("_bl") | ends_with("_eot"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long1 <- data_long1 %>% 
  select(record_id, 
         contact_treatment,
         time,
         pcl,
         isi,
         pcs,
         mcs,
         penn,
         phq,
         hit,
         bpisev,
         bpiinf,
         dbas,
         fosq,
         ess)

data_long1

```

* Diaries WASO, SOL, EMA

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long2 <- itt_raw %>%
  pivot_longer(
    cols = ends_with("_bl_fx_i") | ends_with("_eot_fx_i"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long2 <- data_long2 %>% 
  select(record_id, 
         contact_treatment,
         time,
         sol,
         waso,
         ema)

data_long2


```

* Diaries

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long3 <- itt_raw %>%
  pivot_longer(
    cols = ends_with("_bl_md") | ends_with("_eot_md"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long3 <- data_long3 %>% 
  select(record_id, 
         contact_treatment,
         time,
         tib,
         tst,
         se,
         sol,
         waso,
         ema)

data_long3

```

* Diaries TIB

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long4 <- itt_raw %>%
  pivot_longer(
    cols = ends_with("_bl_mn") | ends_with("_eot_mn"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long4 <- data_long4 %>% 
  select(record_id, 
         contact_treatment,
         time,
         tib,
         tst,
         se,
         sol,
         waso,
         ema)

data_long4

```


* Combine Long Dataframes

```{r}
# Join Data on Record ID and Time
merged_long_itt <- data_long1 %>%
  #left_join(data_long2, by = c("record_id", "time", "contact_treatment")) %>%   
  #left_join(data_long3, by = c("record_id", "time", "contact_treatment"))
  left_join(data_long4, by = c("record_id", "time", "contact_treatment"))  

# View the merged data frame
#merged_long_itt

# Update the time levels from 'bl' to 'Pre' and 'eot' to 'Post', and set factor levels
merged_long_itt <- merged_long_itt %>%
  mutate(time = dplyr::recode(time, bl = "Pre", eot = "Post"),    # Recode time variable
         time = factor(time, levels = c("Pre", "Post")))   # Set order of levels for time



merged_long_itt_cbti <- merged_long_itt %>%
  filter(contact_treatment == 'CBTI') %>%
  mutate(time = dplyr::recode(time, bl = "Pre", eot = "Post"),    # Recode time variable
         time = factor(time, levels = c("Pre", "Post")))   # Set order of levels for time

  
write.csv(merged_long_itt, "ITT/Data/itt_unscaled_time1_time2.csv", row.names = FALSE)
write.csv(merged_long_itt_cbti, "ITT/Data/itt_unscaled_cbti_time1_time2.csv", row.names = FALSE)
```


##### Create Output of Descriptive Statistics

```{r}
# Example usage with your data
mean_sd_table <- mean_sd_table_function(merged_long_itt)

# View the result
mean_sd_table <- mean_sd_table %>% select(!c(record_id_mean, record_id_sd))
mean_sd_table

write.csv(mean_sd_table, "ITT/Data/itt_unscaled_time1_time2_mean_sd_table.csv", row.names = FALSE)
```

##### Prep Data

```{r}
# First convert to factor, then relevel
merged_long_itt$contact_treatment <- as.factor(merged_long_itt$contact_treatment)
merged_long_itt$contact_treatment <- relevel(merged_long_itt$contact_treatment, ref = "CBTI")

```


#### Primary Outcome

##### ISI - Treatment vs. Control 

```{R}
# Fit the model
isi_model <- lmerTest::lmer(isi ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(isi_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(isi_model)
r2_nakagawa

# Pairwise comparisons
emmeans(isi_model, pairwise ~ time | contact_treatment)

# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(isi, na.rm = TRUE), .groups = 'drop')

# Get predicted values from the model
predictions <- ggpredict(isi_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(isi_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["isi"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(isi_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['isi_time']] <- time_label
lmer_itt_eot_effects[['isi_group']] <- group_label
lmer_itt_eot_effects[['isi_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in ISI Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "ISI Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_isi_itx_plot.png", plot = p, width = 8, height = 6)
```


##### ISI - Treatment Only

```{R}
# Calculate standard deviations for each timepoint
sd_data <- merged_long_itt_cbti %>%
  group_by(time) %>%
  summarise(sd = sd(isi, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
isi_model <- lmerTest::lmer(isi ~ time + (1|record_id), data = merged_long_itt_cbti)

# Get full summary
summary(isi_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(isi_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(isi_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(isi_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(isi_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["isi"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(isi_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['isi_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(merged_long_itt_cbti$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in ISI Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "ISI Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_isi_cbti_plot.png", plot = p, width = 8, height = 6)
```


#### Secondary Outcomes

##### TIB - Treatment vs. Control

```{r}
# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(tib, na.rm = TRUE), .groups = 'drop')

# Fit the model
tib_model <- lmerTest::lmer(tib ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(tib_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tib_model)
r2_nakagawa

# Pairwise comparisons
emmeans(tib_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(tib_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(tib_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["tib"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tib_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['tib_time']] <- time_label
lmer_itt_eot_effects[['tib_group']] <- group_label
lmer_itt_eot_effects[['tib_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in Mean TIB Pre- and Post-Treatment",
    x = "Timepoint",
    y = "TIB (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_tib_itx_plot.png", plot = p, width = 8, height = 6)
```

##### TIB - Treatment Only

```{r}
# Calculate standard deviations for each timepoint
sd_data <- merged_long_itt_cbti %>%
  group_by(time) %>%
  summarise(sd = sd(tib, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
tib_model <- lmerTest::lmer(tib ~ time + (1|record_id), data = merged_long_itt_cbti)

# Get full summary
summary(tib_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tib_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(tib_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(tib_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(tib_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["tib"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tib_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['tib_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(merged_long_itt_cbti$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in TIB Pre- and Post-Treatment",
    x = "Timepoint",
    y = "TIB (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_tib_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### TST - Treatment vs. Control

```{r}
# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(tst, na.rm = TRUE), .groups = 'drop')

# Fit the model
tst_model <- lmerTest::lmer(tst ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(tst_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tst_model)
r2_nakagawa

# Pairwise comparisons
emmeans(tst_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(tst_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(tst_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["tst"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tst_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['tst_time']] <- time_label
lmer_itt_eot_effects[['tst_group']] <- group_label
lmer_itt_eot_effects[['tst_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in Mean TST Pre- and Post-Treatment",
    x = "Timepoint",
    y = "TST (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +  
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_tst_itx_plot.png", plot = p, width = 8, height = 6)
```


##### TST - Treatment Only

```{R}
# Calculate standard deviations for each timepoint
sd_data <- merged_long_itt_cbti %>%
  group_by(time) %>%
  summarise(sd = sd(tst, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
tst_model <- lmerTest::lmer(tst ~ time + (1|record_id), data = merged_long_itt_cbti)

# Get full summary
summary(tst_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tst_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(tst_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(tst_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(tst_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["tst"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tst_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['tst_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(merged_long_itt_cbti$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in TST Pre- and Post-Treatment",
    x = "Timepoint",
    y = "TST (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_tst_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### SE - Treatment vs. Control

```{r}
# Fit the model
se_model <- lmerTest::lmer(se ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(se_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(se_model)
r2_nakagawa

# Pairwise comparisons
emmeans(se_model, pairwise ~ time | contact_treatment)

# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(se, na.rm = TRUE), .groups = 'drop')

# Get predicted values from the model
predictions <- ggpredict(se_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(se_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["se"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(se_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['se_time']] <- time_label
lmer_itt_eot_effects[['se_group']] <- group_label
lmer_itt_eot_effects[['se_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SE Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "Sleep Efficiency (%)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +  # You might want to adjust these limits for SE
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_se_itx_plot.png", plot = p, width = 8, height = 6)
```

##### SE - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(se))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(se, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
se_model <- lmerTest::lmer(se ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(se_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(se_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(se_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(se_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(se_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["se"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(se_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['se_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SE Pre- and Post-Treatment",
    x = "Timepoint",
    y = "SE (%)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(70, 95), breaks = seq(70, 95, by = 5)) + # Adjusted for SE percentages
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_se_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### PHQ - Treatment vs. Control

```{r}
# Fit the model
phq_model <- lmerTest::lmer(phq ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(phq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(phq_model)
r2_nakagawa

# Pairwise comparisons
emmeans(phq_model, pairwise ~ time | contact_treatment)

# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(phq, na.rm = TRUE), .groups = 'drop')

# Get predicted values from the model
predictions <- ggpredict(phq_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(phq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["phq"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(phq_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['phq_time']] <- time_label
lmer_itt_eot_effects[['phq_group']] <- group_label
lmer_itt_eot_effects[['phq_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in PHQ Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "PHQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_phq_itx_plot.png", plot = p, width = 8, height = 6)
```

##### PHQ - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(phq))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(phq, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
phq_model <- lmerTest::lmer(phq ~ time + (1|record_id), data = merged_long_itt_cbti)

# Get full summary
summary(phq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(phq_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(phq_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(phq_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(phq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["phq"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(phq_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['phq_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in PHQ-9 Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "PHQ-9 Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 15), breaks = seq(0, 15, by = 3)) + # Adjusted for PHQ-9 scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_phq_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### PCS - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt %>%
  group_by(record_id) %>%
  filter(all(!is.na(pcs))) %>%
  ungroup()

# Fit the model
pcs_model <- lmerTest::lmer(pcs ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(pcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(pcs_model)
r2_nakagawa

# Pairwise comparisons
emmeans(pcs_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(pcs_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(pcs, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(pcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["pcs"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(pcs_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['pcs_time']] <- time_label
lmer_itt_eot_effects[['pcs_group']] <- group_label
lmer_itt_eot_effects[['pcs_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SF36 PCS Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "PCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_pcs_itx_plot.png", plot = p, width = 8, height = 6)
```

##### PCS - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(pcs))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(pcs, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
pcs_model <- lmerTest::lmer(pcs ~ time + (1|record_id), data = merged_long_itt_cbti)

# Get full summary
summary(pcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(pcs_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(pcs_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(pcs_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(pcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["pcs"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(pcs_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['pcs_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SF36 PCS Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "PCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) + # Adjusted for PCS scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_pcs_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### MCS - Treatment vs. Control

```{r}
# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(mcs, na.rm = TRUE), .groups = 'drop')

# Fit the model
mcs_model <- lmerTest::lmer(mcs ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(mcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(mcs_model)
r2_nakagawa

# Pairwise comparisons
emmeans(mcs_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(mcs_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(mcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["mcs"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(mcs_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['mcs_time']] <- time_label
lmer_itt_eot_effects[['mcs_group']] <- group_label
lmer_itt_eot_effects[['mcs_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SF36 MCS Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "MCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_mcs_itx_plot.png", plot = p, width = 8, height = 6)
```

##### MCS - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(mcs))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(mcs, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
mcs_model <- lmerTest::lmer(mcs ~ time + (1|record_id), data = merged_long_itt_cbti)

# Get full summary
summary(mcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(mcs_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(mcs_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(mcs_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(mcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["mcs"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(mcs_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['mcs_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SF36 MCS Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "MCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) + # Adjusted for MCS scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_mcs_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### FOSQ - Treatment vs. Control

```{r}
# Fit the model
fosq_model <- lmerTest::lmer(fosq ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(fosq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(fosq_model)
r2_nakagawa

# Pairwise comparisons
emmeans(fosq_model, pairwise ~ time | contact_treatment)

# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(fosq, na.rm = TRUE), .groups = 'drop')

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Get predicted values from the model
predictions <- ggpredict(fosq_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(fosq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["fosq"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(fosq_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['fosq_time']] <- time_label
lmer_itt_eot_effects[['fosq_group']] <- group_label
lmer_itt_eot_effects[['fosq_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in FOSQ Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "FOSQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +  # You might want to adjust these limits for FOSQ
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fosq_itx_plot.png", plot = p, width = 8, height = 6)
```

##### FOSQ - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(fosq))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(fosq, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
fosq_model <- lmerTest::lmer(fosq ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(fosq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(fosq_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(fosq_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(fosq_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(fosq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["fosq"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(fosq_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['fosq_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in FOSQ Scores Pre- and Post-Treatment",
    x = "Timepoint",
    y = "FOSQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(10, 20), breaks = seq(10, 20, by = 2)) + # Adjusted for FOSQ scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fosq_cbti_plot.png", plot = p, width = 8, height = 6)
```

##### WASO - Treatment vs. Control 

```{r}
# Fit the model
waso_model <- lmerTest::lmer(waso ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(waso_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(waso_model)
r2_nakagawa

# Pairwise comparisons
emmeans(waso_model, pairwise ~ time | contact_treatment)

# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(waso, na.rm = TRUE), .groups = 'drop')

# Get predicted values from the model
predictions <- ggpredict(waso_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(waso_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["waso"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(waso_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['waso_time']] <- time_label
lmer_itt_eot_effects[['waso_group']] <- group_label
lmer_itt_eot_effects[['waso_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.2f (%.2f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in Mean WASO Pre- and Post-Treatment",
    x = "Timepoint",
    y = "WASO (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_waso_itx_plot.png", plot = p, width = 8, height = 6)
```


##### WASO - Treatment Only

```{r}
# Calculate standard deviations for each timepoint
sd_data <- merged_long_itt_cbti %>%
  group_by(time) %>%
  summarise(sd = sd(waso, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
waso_model <- lmerTest::lmer(waso ~ time + (1|record_id), data = merged_long_itt_cbti)

# Get full summary
summary(waso_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(waso_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(waso_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(waso_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(waso_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["waso"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(waso_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['waso_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(merged_long_itt_cbti$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in WASO Pre- and Post-Treatment",
    x = "Timepoint",
    y = "WASO (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Adjusted for WASO scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_waso_cbti_plot.png", plot = p, width = 8, height = 6)
```


##### SOL - Treatment vs. Control

```{r}
# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(sol, na.rm = TRUE), .groups = 'drop')

# Fit the model
sol_model <- lmerTest::lmer(sol ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(sol_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(sol_model)
r2_nakagawa

# Pairwise comparisons
emmeans(sol_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(sol_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(sol_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["sol"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(sol_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['sol_time']] <- time_label
lmer_itt_eot_effects[['sol_group']] <- group_label
lmer_itt_eot_effects[['sol_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in Mean SOL Pre- and Post-Treatment",
    x = "Timepoint",
    y = "SOL (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_sol_itx_plot.png", plot = p, width = 8, height = 6)
```

##### SOL - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(sol))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(sol, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
sol_model <- lmerTest::lmer(sol ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(sol_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(sol_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(sol_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(sol_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(sol_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["sol"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(sol_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['sol_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SOL Pre- and Post-Treatment",
    x = "Timepoint",
    y = "SOL (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Adjusted for SOL scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_sol_cbti_plot.png", plot = p, width = 8, height = 6)
```

##### EMA - Treatment vs. Control

```{r}
# Fit the model
ema_model <- lmerTest::lmer(ema ~ time * contact_treatment + (1|record_id), data = merged_long_itt)

# Get full summary
summary(ema_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(ema_model)
r2_nakagawa

# Pairwise comparisons
emmeans(ema_model, pairwise ~ time | contact_treatment)

# Calculate standard deviations for each group at each timepoint
sd_data <- merged_long_itt %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(ema, na.rm = TRUE), .groups = 'drop')

# Get predicted values from the model
predictions <- ggpredict(ema_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Calculate sample size for each treatment group
n_sizes <- merged_long_itt %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Extract p-values from model
model_sum <- summary(ema_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_results[["ema"]] <- fixed_effects

fixed_effects

# Create labels for p-values and effect sizes
time_p <- fixed_effects["timePost", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
interaction_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(ema_model)

# Create labels using the function
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[3], "Group")
interaction_label <- create_effect_label(interaction_p, std_coef$Std_Coefficient[4], "Interaction")

# Add effect sizes to list
lmer_itt_eot_effects[['ema_time']] <- time_label
lmer_itt_eot_effects[['ema_group']] <- group_label
lmer_itt_eot_effects[['ema_intx']] <- interaction_label

# Combine labels
combined_label <- paste(group_label, time_label, interaction_label, sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in Mean EMA Pre- and Post-Treatment",
    x = "Timepoint",
    y = "EMA (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_ema_itx_plot.png", plot = p, width = 8, height = 6)
```


##### EMA - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(ema))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(ema, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
ema_model <- lmerTest::lmer(ema ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(ema_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(ema_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(ema_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(ema_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(ema_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_eot_cbti_results[["ema"]] <- fixed_effects

# Create labels for p-values and effect sizes (simplified)
time_p <- fixed_effects["timePost", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(ema_model)

# Create label using the function (time only)
time_label <- create_effect_label(time_p, std_coef$Std_Coefficient[2], "Time")

# Add effect sizes to list
lmer_itt_eot_cbti_effects[['ema_time']] <- time_label

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in Early Morning Awakening Pre- and Post-Treatment",
    x = "Timepoint",
    y = "EMA (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Adjusted for EMA scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = time_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_ema_cbti_plot.png", plot = p, width = 8, height = 6)
```

#### Statistical Test Results - All LMERs - Treatment vs. Control

```{r}
# Convert nested list to dataframe
lmer_itt_eot_results_df <- do.call(rbind, lapply(names(lmer_itt_eot_results), function(var) {
  df <- as.data.frame(lmer_itt_eot_results[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))

# Clean up the dataframe
lmer_itt_eot_results_df <- lmer_itt_eot_results_df %>%
  select(Variable, Parameter, everything()) %>%  # Reorder columns
  mutate(across(where(is.numeric), round, 3))   # Round numeric columns

# Filter for specific effects
filtered_results <- lmer_itt_eot_results_df %>%
  filter(Parameter %in% c("timePost", "contact_treatmentCTRL", "timePost:contact_treatmentCTRL"))

# Create wider format
wide_itt_eot_results <- filtered_results %>%
  select(Variable, Parameter, `Pr(>|t|)`) %>%
  pivot_wider(
    names_from = Parameter,
    values_from = `Pr(>|t|)`,
    names_prefix = "p_"
  )

# Add p-adj to wide results
wide_itt_eot_results$p_adj_intx <- round(p.adjust(wide_itt_eot_results$`p_timePost:contact_treatmentCTRL`, method = "bonferroni"),3)

# Add effect sizes
lmer_itt_eot_effects_df <- do.call(rbind, lapply(names(lmer_itt_eot_effects), function(var) {
  df <- as.data.frame(lmer_itt_eot_effects[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))

# Print the results
kable(print(lmer_itt_eot_results_df))  # Full results
kable(print(wide_itt_eot_results))     # Wide format results
kable(print(lmer_itt_eot_effects_df))  # Effect sizes

# Save outputs
write.csv(lmer_itt_eot_results_df, "ITT/Results/itt_eot_lmer_results.csv", row.names = FALSE)
write.csv(wide_itt_eot_results, "ITT/Results/itt_eot_lmer_p_adj.csv", row.names = FALSE)
write.csv(lmer_itt_eot_effects_df, "ITT/Results/itt_eot_lmer_effects.csv", row.names = FALSE)
```

#### Statistical Test Results - All LMERs - Treatment Only

```{r}
# Convert nested list to dataframe
lmer_itt_eot_cbti_results_df <- do.call(rbind, lapply(names(lmer_itt_eot_cbti_results), function(var) {
  df <- as.data.frame(lmer_itt_eot_cbti_results[[var]])
  df$Variable <- var
  df$Parameter <- rownames(df)
  rownames(df) <- NULL
  return(df)
}))

# Clean up the dataframe
lmer_itt_eot_cbti_results_df <- lmer_itt_eot_cbti_results_df %>%
  select(Variable, Parameter, everything()) %>%  # Reorder columns
  mutate(across(where(is.numeric), round, 3))   # Round numeric columns

# Filter for specific effects (simplified for time only)
filtered_results <- lmer_itt_eot_cbti_results_df %>%
  filter(Parameter == "timePost")

# Create wider format
wide_itt_eot_cbti_results <- filtered_results %>%
  select(Variable, Parameter, `Pr(>|t|)`) %>%
  pivot_wider(
    names_from = Parameter,
    values_from = `Pr(>|t|)`,
    names_prefix = "p_"
  )

# Add adjusted p-values
wide_itt_eot_cbti_results$p_adj_time <- round(p.adjust(wide_itt_eot_cbti_results$p_timePost, 
                                                      method = "bonferroni"), 3)

# Add effect sizes
lmer_itt_eot_cbti_effects_df <- do.call(rbind, lapply(names(lmer_itt_eot_cbti_effects), function(var) {
  data.frame(
    Variable = var,
    Effect_Label = lmer_itt_eot_cbti_effects[[var]],
    stringsAsFactors = FALSE
  )
}))

# Print the results
kable(print(lmer_itt_eot_cbti_results_df))  # Full results
kable(print(wide_itt_eot_cbti_results))     # Wide format results
kable(print(lmer_itt_eot_cbti_effects_df))  # Effect sizes

# Save outputs
write.csv(lmer_itt_eot_cbti_results_df, 
          "ITT/Results/itt_eot_cbti_lmer_results.csv", 
          row.names = FALSE)

write.csv(wide_itt_eot_cbti_results, 
          "ITT/Results/itt_eot_cbti_lmer_p_adj.csv", 
          row.names = FALSE)

write.csv(lmer_itt_eot_cbti_effects_df, 
          "ITT/Results/itt_eot_cbti_lmer_effects.csv", 
          row.names = FALSE)

```



## Through Follow Up

### Prep Data

```{r}
# View(data_clean)
#data_fu_prep_itt <- data_clean  # Raw data including all follow up columns

# Save raw data to directory
#write.csv(data_fu_prep_itt, "ITT/Data/itt_fu_prep_raw_data.csv", row.names = FALSE)

# Check number of randomized to treatment
#table(data_fu_prep_itt$contact_treatment)
```


### Apply to Data

```{r}
# Scale the data
# scaled_result <- center_scale_data(your_data, exclude_cols = c("id", "group"))
# scaled_data <- scaled_result$scaled_data
# scaling_params <- scaled_result$scaling_params
# Reverse the scaling
# original_data <- reverse_scaling(scaled_data, scaling_params)

# Apply skew correction, centering, and scaling
#corrected_fu_itt <- center_scale_data(data_fu_prep_itt, exclude_cols = c("record_id"))
#fu_scaling_params <- corrected_fu_itt$scaling_params
#corrected_fu_itt <- corrected_fu_itt$scaled_data

# Save transformed data to directory
#write.csv(corrected_fu_itt, "ITT/Data/itt_fu_prep_transformed_data.csv", row.names = FALSE)

#View(corrected_fu_itt)
```


### Impute Missing Data via Multiple Imputations - commented out after running this once

```{r}
# Perform multiple imputation on scaled follow up data
#imputed_fu_dataset <- mice(corrected_fu_itt %>% dplyr::select(-'record_id'), m = 5, method = "pmm", ridge = 0.01, seed = 1)

# Inspect the imputed datasets
#print(imputed_fu_dataset)

```


```{r}

# Combine the imputed datasets into one dataframe
#combined_imputed_fu_data <- complete(imputed_fu_dataset, "long", include = FALSE)

# Drop extra columns
#combined_imputed_fu_data <- combined_imputed_fu_data %>% select(!c(.imp, .id))

# Add new index column for ID
#combined_imputed_fu_data$record_id <- seq_len(nrow(combined_imputed_fu_data))

# Save the dataframe as a .csv file for scaled, imputed data
#write.csv(combined_imputed_fu_data, "ITT/Data/itt_fu_imputed_data.csv", row.names = FALSE)

# Undo scaling of ITT data so its back in original units
#itt_fu_raw <- reverse_scaling(combined_imputed_fu_data, fu_scaling_params)
#View(itt_fu_raw)

# Save ITT data in original units
#write.csv(itt_fu_raw, "ITT/Data/itt_fu_unscaled_data.csv", row.names = FALSE)

itt_fu_raw <- read_csv("ITT/Data/itt_fu_unscaled_data.csv")

```

```{r}
# Update treatment label to CTRL for abti

itt_fu_raw$contact_treatment <- factor(itt_fu_raw$contact_treatment,
                                    levels = c('CBTI', 'ABTI'),
                                    labels = c('CBTI', 'CTRL'))

```

### Linear Mixed Effects Models

```{r}
lmer_itt_fu_results <- list()
lmer_itt_fu_effects <- list()
lmer_itt_fu_cbti_results <- list()
lmer_itt_fu_cbti_effects <- list()
```


#### Delta Differences for Abstract Reporting (means, sd)

```{r}
#itt_fu_table %>%
#  gt() %>%
#  fmt_number(columns = c(mean, sd), decimals = 2) %>%
#  cols_label(
#    contact_treatment = "Treatment Group",
#    variable = "Variable",
#    mean = "Mean",
#    sd = "SD"
#  ) %>%
#  tab_header(
#    title = "Treatment Group Differences"
#  ) %>%
#  gtsave("ITT/Graphs/itt_fu_delta_table.png")

# Save as TXT
#write.table(itt_fu_table, 
#            file = "ITT/Data/itt_fu_table.txt", 
#            sep = "\t", 
#            row.names = FALSE, 
#            quote = FALSE)

```



### Create Long Format for Data

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long1 <- itt_fu_raw %>%
  pivot_longer(
    cols = ends_with("_bl") | ends_with("_eot") | ends_with("_fu"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot|fu)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long1 <- data_long1 %>% 
  select(record_id, 
         contact_treatment,
         time,
         pcl,
         isi,
         pcs,
         mcs,
         penn,
         phq,
         hit,
         bpisev,
         bpiinf,
         dbas,
         fosq,
         ess)

data_long1

```

* Diaries WASO, SOL, EMA

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long2 <- itt_fu_raw %>%
  pivot_longer(
    cols = ends_with("_bl_fx_i") | ends_with("_eot_fx_i") | ends_with("_fu_fx_i"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot|fu)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long2 <- data_long2 %>% 
  select(record_id, 
         contact_treatment,
         time,
         sol,
         waso,
         ema)

data_long2


```

* Diaries TIB

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long3 <- itt_fu_raw %>%
  pivot_longer(
    cols = ends_with("_bl_md") | ends_with("_eot_md") | ends_with("_fu_md"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot|fu)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long3 <- data_long3 %>% 
  select(record_id, 
         contact_treatment,
         time,
         tib,
         tst,
         sol,
         waso,
         ema)

data_long3

```


* Diaries Metrics - Means

```{r}
# Pivot the data from wide to long format for all pre- and post- variables
data_long4 <- itt_fu_raw %>%
  pivot_longer(
    cols = ends_with("_bl_mn") | ends_with("_eot_mn") | ends_with("_fu_md"),   # Select all pre and post columns
    names_to = c(".value", "time"),                # Separate into new columns: '.value' will hold variable names
    names_pattern = "(.*)_(bl|eot|fu)"              # Regex to capture variable name and time (pre/post)
  )

# View the reshaped long format data
data_long4 <- data_long4 %>% 
  select(record_id, 
         contact_treatment,
         time,
         tib,
         tst,
         se,
         sol,
         waso,
         ema
         )

data_long4

```

* Combine Long Dataframes

```{r}
# Join Data on Record ID and Time
merged_long_itt_fu <- data_long1 %>%
  #left_join(data_long2, by = c("record_id", "time", "contact_treatment")) %>%   
  #left_join(data_long3, by = c("record_id", "time", "contact_treatment"))
  left_join(data_long4, by = c("record_id", "time", "contact_treatment"))


# Update the time levels from 'bl' to 'Pre' and 'eot' to 'Post', and set factor levels
merged_long_itt_fu <- merged_long_itt_fu %>%
  mutate(time = dplyr::recode(time, bl = "Pre", eot = "Post", fu = "FollowUp"),    # Recode time variable
         time = factor(time, levels = c("Pre", "Post", "FollowUp")))   # Set order of levels for time

# Save data of CBTI group only
merged_long_itt_fu_cbti <- merged_long_itt_fu %>% filter(contact_treatment == 'CBTI')
write.csv(merged_long_itt_fu_cbti, "ITT/Data/itt_fu_cbti_time1_time2_time3_raw.csv", row.names = FALSE)
write.csv(merged_long_itt_fu, "ITT/Data/itt_fu_unscaled_time1_time2_time3.csv", row.names = FALSE)
```


### Create Output of Descriptive Statistics

```{r}
mean_sd_table_itt_fu <- mean_sd_table_function(merged_long_itt_fu)

# View the result
kable(mean_sd_table_itt_fu)

write.csv(mean_sd_table_itt_fu, "ITT/Data/itt_fu_raw_mean_sd_table.csv", row.names = FALSE)
```


##### Prep Data

```{r}
# First convert to factor, then relevel
merged_long_itt_fu$contact_treatment <- as.factor(merged_long_itt_fu$contact_treatment)
merged_long_itt_fu$contact_treatment <- relevel(merged_long_itt_fu$contact_treatment, ref = "CBTI")
```


#### Primary Outcome

###### ISI - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(isi))) %>%
  ungroup()

# Calculate standard deviations for each group at each timepoint
sd_data <- filtered_data %>%
  group_by(time, contact_treatment) %>%
  summarise(sd = sd(isi, na.rm = TRUE), .groups = 'drop')

# Calculate sample size for each treatment group
n_sizes <- filtered_data %>%
  group_by(contact_treatment) %>%
  summarise(n = n_distinct(record_id)) %>%
  ungroup()

# Create new labels for the legend
group_labels <- paste0(n_sizes$contact_treatment, " (n=", n_sizes$n, ")")
names(group_labels) <- n_sizes$contact_treatment

# Fit the model
isi_model <- lmerTest::lmer(isi ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(isi_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(isi_model)
r2_nakagawa

# Pairwise comparisons
emmeans(isi_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(isi_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Convert to wide format to match with predictions
sd_wide <- sd_data %>%
  mutate(group_time = paste(contact_treatment, time)) %>%
  select(group_time, sd)

# Add SD to predictions dataframe
pred_df$group_time <- paste(pred_df$group, pred_df$x)
pred_df <- merge(pred_df, sd_wide, by = "group_time", all.x = TRUE)

# Extract p-values from model
model_sum <- summary(isi_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["isi"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(isi_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_effects[['isi_p_time']] <- time_post_label
lmer_itt_fu_effects[['isi_f_time']] <- time_fu_label
lmer_itt_fu_effects[['isi_group']] <- group_label
lmer_itt_fu_effects[['isi_p_group_intx']] <- post_group_int_label
lmer_itt_fu_effects[['isi_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in ISI Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "ISI Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey(labels = group_labels) +
  scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_isi_itx_plot.png", plot = p, width = 8, height = 6)
```

###### ISI - Treatment Only


```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(isi))) %>%
  ungroup()

# Calculate standard deviations for each timepoint
sd_data <- filtered_data %>%
  group_by(time) %>%
  summarise(sd = sd(isi, na.rm = TRUE), .groups = 'drop')

# Fit the model (removed contact_treatment)
isi_model <- lmerTest::lmer(isi ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(isi_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(isi_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(isi_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(isi_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Add SD to predictions dataframe
pred_df <- merge(pred_df, sd_data, by.x = "x", by.y = "time")

# Extract p-values from model
model_sum <- summary(isi_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["isi"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(isi_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['isi_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['isi_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Calculate sample size
n_size <- n_distinct(filtered_data$record_id)

# Create the plot with legend
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) +
  geom_line(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 1) +
  geom_point(aes(color = sprintf("CBTI (n=%d)", n_size)), size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = sprintf("%.1f (%.1f)", predicted, sd)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in ISI Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "ISI Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_manual(values = "black") +
  scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_isi_cbti_plot.png", plot = p, width = 8, height = 6)
```


#### Secondary Outcomes

###### TIB - Treatment vs. Control

```{R}

# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(tib))) %>%
  ungroup()

# Fit the model
tib_model <- lmerTest::lmer(tib ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(tib_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tib_model)
r2_nakagawa

# Pairwise comparisons
emmeans(tib_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(tib_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(tib_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["tib"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(tib_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['tib_p_time']] <- time_post_label
lmer_itt_fu_results[['tib_f_time']] <- time_fu_label
lmer_itt_fu_results[['tib_group']] <- group_label
lmer_itt_fu_results[['tib_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['tib_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in TIB Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "TIB (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_tib_itx_plot.png", plot = p, width = 8, height = 6)

```

###### TIB - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(tib))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
tib_model <- lmerTest::lmer(tib ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(tib_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tib_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(tib_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(tib_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(tib_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["tib"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tib_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['tib_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['tib_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in TIB Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "TIB (hr)"
  ) +
  theme_minimal() +
  scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) + # Updated scale for TIB
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_tib_cbti_plot.png", plot = p, width = 8, height = 6)

```

###### TST - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(tst))) %>%
  ungroup()

# Fit the model
tst_model <- lmerTest::lmer(tst ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(tst_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tst_model)
r2_nakagawa

# Pairwise comparisons
emmeans(tst_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(tst_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(tst_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["tst"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(tst_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['tst_p_time']] <- time_post_label
lmer_itt_fu_results[['tst_f_time']] <- time_fu_label
lmer_itt_fu_results[['tst_group']] <- group_label
lmer_itt_fu_results[['tst_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['tst_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in TST Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "TST (hr)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(5, 20), breaks = seq(5, 20, by = 5)) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_tst_itx_plot.png", plot = p, width = 8, height = 6)

```


###### TST - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(tst))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
tst_model <- lmerTest::lmer(tst ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(tst_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(tst_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(tst_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(tst_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(tst_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["tst"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(tst_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['tst_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['tst_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in TST Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "TST (hr)"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(6, 9), breaks = seq(6, 9, by = 1)) + # Updated scale for TST
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_tst_cbti_plot.png", plot = p, width = 8, height = 6)

```

###### SE - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(se))) %>%
  ungroup()

# Fit the model
se_model <- lmerTest::lmer(se ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(se_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(se_model)
r2_nakagawa

# Pairwise comparisons
emmeans(se_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(se_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(se_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["se"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(se_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['se_p_time']] <- time_post_label
lmer_itt_fu_results[['se_f_time']] <- time_fu_label
lmer_itt_fu_results[['se_group']] <- group_label
lmer_itt_fu_results[['se_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['se_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SE Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "SE (%)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(70, 95), breaks = seq(70, 95, by = 5)) + # Updated scale for SE
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_se_itx_plot.png", plot = p, width = 8, height = 6)

```

###### SE - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(se))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
se_model <- lmerTest::lmer(se ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(se_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(se_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(se_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(se_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(se_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["se"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(se_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['se_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['se_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SE Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "SE (%)"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(70, 95), breaks = seq(70, 95, by = 5)) + # Adjusted for SE scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_se_cbti_plot.png", plot = p, width = 8, height = 6)

```

###### PHQ - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(phq))) %>%
  ungroup()

# Fit the model
phq_model <- lmerTest::lmer(phq ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(phq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(phq_model)
r2_nakagawa

# Pairwise comparisons
emmeans(phq_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(phq_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(phq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["phq"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(phq_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['phq_p_time']] <- time_post_label
lmer_itt_fu_results[['phq_f_time']] <- time_fu_label
lmer_itt_fu_results[['phq_group']] <- group_label
lmer_itt_fu_results[['phq_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['phq_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in PHQ Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "PHQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(0, 15), breaks = seq(0, 15, by = 3)) + # Updated scale for PHQ
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_phq_itx_plot.png", plot = p, width = 8, height = 6)

```


###### PHQ - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(phq))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
phq_model <- lmerTest::lmer(phq ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(phq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(phq_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(phq_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(phq_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(phq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["phq"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(phq_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['phq_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['phq_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in PHQ Scores Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "PHQ Score"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(0, 15), breaks = seq(0, 15, by = 3)) + # Adjusted scale for PHQ
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_phq_cbti_plot.png", plot = p, width = 8, height = 6)
```


###### PCS - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(pcs))) %>%
  ungroup()

# Fit the model
pcs_model <- lmerTest::lmer(pcs ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(pcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(pcs_model)
r2_nakagawa

# Pairwise comparisons
emmeans(pcs_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(pcs_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(pcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["pcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(pcs_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['pcs_p_time']] <- time_post_label
lmer_itt_fu_results[['pcs_f_time']] <- time_fu_label
lmer_itt_fu_results[['pcs_group']] <- group_label
lmer_itt_fu_results[['pcs_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['pcs_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in PCS Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "PCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) + # Updated scale for PCS
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_pcs_itx_plot.png", plot = p, width = 8, height = 6)
```

###### PCS - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(pcs))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
pcs_model <- lmerTest::lmer(pcs ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(pcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(pcs_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(pcs_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(pcs_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(pcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["pcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(pcs_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['pcs_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['pcs_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SF36 PCS Scores Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "PCS Score"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) + # Updated scale for PCS
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_pcs_cbti_plot.png", plot = p, width = 8, height = 6)
```

###### MCS - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(mcs))) %>%
  ungroup()

# Fit the model
mcs_model <- lmerTest::lmer(mcs ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(mcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(mcs_model)
r2_nakagawa

# Pairwise comparisons
emmeans(mcs_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(mcs_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(mcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["mcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(mcs_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['mcs_p_time']] <- time_post_label
lmer_itt_fu_results[['mcs_f_time']] <- time_fu_label
lmer_itt_fu_results[['mcs_group']] <- group_label
lmer_itt_fu_results[['mcs_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['mcs_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in MCS Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "MCS Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) + # Updated scale for MCS
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_mcs_itx_plot.png", plot = p, width = 8, height = 6)

```

###### MCS - Treatment Only

```{R}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(mcs))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
mcs_model <- lmerTest::lmer(mcs ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(mcs_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(mcs_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(mcs_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(mcs_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(mcs_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["mcs"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(mcs_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['mcs_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['mcs_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in MCS Scores Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "MCS Score"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(30, 50), breaks = seq(30, 50, by = 5)) + # Updated scale for MCS
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_mcs_cbti_plot.png", plot = p, width = 8, height = 6)
```

###### FOSQ - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(fosq))) %>%
  ungroup()

# Fit the model
fosq_model <- lmerTest::lmer(fosq ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(fosq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(fosq_model)
r2_nakagawa

# Pairwise comparisons
emmeans(fosq_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(fosq_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(fosq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["fosq"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(fosq_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['fosq_p_time']] <- time_post_label
lmer_itt_fu_results[['fosq_f_time']] <- time_fu_label
lmer_itt_fu_results[['fosq_group']] <- group_label
lmer_itt_fu_results[['fosq_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['fosq_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in FOSQ Scores Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "FOSQ Score",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(10, 20), breaks = seq(10, 20, by = 2)) + # Updated scale for FOSQ
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_fosq_itx_plot.png", plot = p, width = 8, height = 6)
```


###### FOSQ - Treatment only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(fosq))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
fosq_model <- lmerTest::lmer(fosq ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(fosq_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(fosq_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(fosq_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(fosq_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(fosq_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["fosq"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(fosq_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['fosq_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['fosq_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in FOSQ Scores Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "FOSQ Score"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(10, 20), breaks = seq(10, 20, by = 2)) + # Adjusted for FOSQ scale
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_fosq_cbti_plot.png", plot = p, width = 8, height = 6)

```

###### WASO - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(waso))) %>%
  ungroup()

# Fit the model
waso_model <- lmerTest::lmer(waso ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(waso_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(waso_model)
r2_nakagawa

# Pairwise comparisons
emmeans(waso_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(waso_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(waso_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["waso"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(waso_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['waso_p_time']] <- time_post_label
lmer_itt_fu_results[['waso_f_time']] <- time_fu_label
lmer_itt_fu_results[['waso_group']] <- group_label
lmer_itt_fu_results[['waso_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['waso_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in WASO Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "WASO (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Updated scale for WASO
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_waso_itx_plot.png", plot = p, width = 8, height = 6)
```


###### WASO - Treatment Only

```{R}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(waso))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
waso_model <- lmerTest::lmer(waso ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(waso_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(waso_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(waso_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(waso_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(waso_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["waso"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(waso_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['waso_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['waso_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in WASO Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "WASO (minutes)"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Updated scale for WASO
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_waso_cbti_plot.png", plot = p, width = 8, height = 6)

```

###### SOL - Treatment vs. Control

```{r}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(sol))) %>%
  ungroup()

# Fit the model
sol_model <- lmerTest::lmer(sol ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(sol_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(sol_model)
r2_nakagawa

# Pairwise comparisons
emmeans(sol_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(sol_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(sol_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["sol"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(sol_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['sol_p_time']] <- time_post_label
lmer_itt_fu_results[['sol_f_time']] <- time_fu_label
lmer_itt_fu_results[['sol_group']] <- group_label
lmer_itt_fu_results[['sol_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['sol_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SOL Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "SOL (min)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Updated scale for SOL
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_sol_itx_plot.png", plot = p, width = 8, height = 6)

```

###### SOL - Treatment Only

```{R}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(sol))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
sol_model <- lmerTest::lmer(sol ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(sol_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(sol_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(sol_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(sol_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(sol_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["sol"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(sol_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['sol_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['sol_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in SOL Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "SOL (minutes)"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Updated scale for SOL
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_sol_cbti_plot.png", plot = p, width = 8, height = 6)

```

###### EMA - Treatment vs. Control

```{R}
# Filter data
filtered_data <- merged_long_itt_fu %>%
  group_by(record_id) %>%
  filter(all(!is.na(ema))) %>%
  ungroup()

# Fit the model
ema_model <- lmerTest::lmer(ema ~ time * contact_treatment + (1|record_id), data = filtered_data)

# Get full summary
summary(ema_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(ema_model)
r2_nakagawa

# Pairwise comparisons
emmeans(ema_model, pairwise ~ time | contact_treatment)

# Get predicted values from the model
predictions <- ggpredict(ema_model, terms = c("time", "contact_treatment"))

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(ema_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_results[["ema"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]
group_p <- fixed_effects["contact_treatmentCTRL", "Pr(>|t|)"]
post_group_int_p <- fixed_effects["timePost:contact_treatmentCTRL", "Pr(>|t|)"]
fu_group_int_p <- fixed_effects["timeFollowUp:contact_treatmentCTRL", "Pr(>|t|)"]

# Create function for formatting labels
create_effect_label <- function(p_value, std_coef, effect_name) {
  effect_size_cat <- ifelse(abs(std_coef) >= 0.5, "large",
                           ifelse(abs(std_coef) >= 0.3, "medium", "small"))
  
  if(p_value < .001) {
    sprintf("%s: p < .001, Beta = %s (%s)", 
            effect_name,
            round(std_coef, 3),
            effect_size_cat)
  } else {
    sprintf("%s: p = %s, Beta = %s (%s)", 
            effect_name,
            round(p_value, 3),
            round(std_coef, 3),
            effect_size_cat)
  }
}

# Get standardized coefficients
std_coef <- standardize_parameters(ema_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post Time")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up Time")
group_label <- create_effect_label(group_p, std_coef$Std_Coefficient[4], "Group")
post_group_int_label <- create_effect_label(post_group_int_p, std_coef$Std_Coefficient[5], "Post/Group Interaction")
fu_group_int_label <- create_effect_label(fu_group_int_p, std_coef$Std_Coefficient[6], "FollowUp/Group Interaction")

# Add effect sizes to list
lmer_itt_fu_results[['ema_p_time']] <- time_post_label
lmer_itt_fu_results[['ema_f_time']] <- time_fu_label
lmer_itt_fu_results[['ema_group']] <- group_label
lmer_itt_fu_results[['ema_p_group_intx']] <- post_group_int_label
lmer_itt_fu_results[['ema_f_group_intx']] <- fu_group_int_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, group_label, post_group_int_label, fu_group_int_label,  sep = "\n")

# Create the plot
p <- ggplot(pred_df, aes(x = x, y = predicted, group = group, color = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in Early Morning Awakening Pre, Post, and Follow Up",
    x = "Timepoint",
    y = "EMA (minutes)",
    color = "Treatment Group"
  ) +
  theme_minimal() +
  scale_color_grey() +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Updated scale for EMA
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "right",
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )
p

ggsave(filename = "ITT/Graphs/itt_fu_ema_itx_plot.png", plot = p, width = 8, height = 6)
```

###### EMA - Treatment Only

```{r}
# Filter data for treatment group only
filtered_data <- merged_long_itt_fu_cbti %>%
  group_by(record_id) %>%
  filter(all(!is.na(ema))) %>%
  ungroup()

# Fit the model (removed contact_treatment)
ema_model <- lmerTest::lmer(ema ~ time + (1|record_id), data = filtered_data)

# Get full summary
summary(ema_model)

# Get effect sizes
r2_nakagawa <- performance::r2_nakagawa(ema_model)
r2_nakagawa

# Pairwise comparisons (simplified for time only)
emmeans(ema_model, pairwise ~ time)

# Get predicted values from the model
predictions <- ggpredict(ema_model, terms = "time")

# Convert predictions to data frame
pred_df <- as.data.frame(predictions)

# Extract p-values from model
model_sum <- summary(ema_model)
fixed_effects <- model_sum$coefficients

# Add model to results list
lmer_itt_fu_cbti_results[["ema"]] <- fixed_effects

# Create labels for p-values and effect sizes
post_p <- fixed_effects["timePost", "Pr(>|t|)"]
fu_p <- fixed_effects["timeFollowUp", "Pr(>|t|)"]

# Get standardized coefficients
std_coef <- standardize_parameters(ema_model)

# Create labels using the function
time_post_label <- create_effect_label(post_p, std_coef$Std_Coefficient[2], "Post vs Pre")
time_fu_label <- create_effect_label(fu_p, std_coef$Std_Coefficient[3], "Follow Up vs Pre")

# Add effect sizes to list
lmer_itt_fu_cbti_effects[['ema_post']] <- time_post_label
lmer_itt_fu_cbti_effects[['ema_fu']] <- time_fu_label

# Combine labels
combined_label <- paste(time_post_label, time_fu_label, sep = "\n")

# Create the plot (simplified for one group)
p <- ggplot(pred_df, aes(x = x, y = predicted, group = 1)) + # Added group = 1
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                width = 0.2) +
  geom_text(aes(label = round(predicted, 1)), 
            vjust = -1.5, 
            color = "black") +
  labs(
    title = "ITT: Change in Early Morning Awakening Pre, Post, and Follow Up (CBTI Group)",
    x = "Timepoint",
    y = "EMA (minutes)"
  ) +
  theme_minimal() +
  #scale_y_continuous(limits = c(0, 120), breaks = seq(0, 120, by = 30)) + # Updated scale for EMA
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(caption = combined_label) +
  theme(
    plot.caption = element_text(hjust = 0, vjust = 1),
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)
  )

p

ggsave(filename = "ITT/Graphs/itt_fu_ema_cbti_plot.png", plot = p, width = 8, height = 6)

```



